<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="SofiaC++"><meta name="description"><title>Libraries and API design&mdash;Advanced C++</title><link href="/advanced-cpp/favicon.png" rel="icon"><link rel="alternate" href="/advanced-cpp/atom.xml" title="config.title" type="application/atom.xml"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet"><link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css" rel="stylesheet"><style>body { padding-top: 50px; }</style></head><body><div class="container"><nav role="navigation" class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Advanced C++</a></div><div id="navbar" class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href="/advanced-cpp/categories/news/">News</a></li><li><a href="/advanced-cpp/categories/slides/">Slides</a></li><li><a href="/advanced-cpp/about/">About</a></li></ul></div></div></nav><div class="page-header"><h1><a href="/advanced-cpp/">Advanced C++</a></h1><p id="site-slogan">Site for the Advanced C++ course at FMI</p></div><div class="row"><div class="col-sm-9"><section id="content"><article class="post"><h2>Libraries and API design</h2><div class="meta">12 Mar 2017 in <a href="/advanced-cpp/categories/slides/">slides</a>&ensp;</div><a href="/advanced-cpp/slides/08_library.html" class="btn btn-large btn-primary">Slide Show</a><p>section
h1 Library API Design</p>
<p>section
h2 What is an API
p Application Program Interface
p The set of functions and types that a library provides</p>
<p>section
h2 Contents
ul
li Kind of libraries
ul
li Header only
li Static
li Dynamic/shared
li Symbol linkage
li interfaces
li Heap allocated objects
li std:: cross library</p>
<p>section
section
h2 Header only libraries
p A collection of header files</p>
<p>section
:markdown
### Pros</p>
<pre><code>* Very easy to use - just copy the files and `#include`
* No overhead at all - even some calls  might get inlined
</code></pre>
<p>section
h3 Cons
ul
li No isolation at all - the client sees all implementation details
li Changes in the library requires recompile
li Difficult to use with non-open-source licenses
li May significantly increase compilation time
li Tends to creep all over the place</p>
<p>section
section
h2 Static Libraries
p An archive of object files</p>
<p>section
h3 Pros
ul
li Relatively easy to use - include and link
li No overhead, some calls might be inlined if we are using optimizing
| linker</p>
<p>section
h3 Cons
ul
li.</p>
<pre><code>    The compiler options must match perfectly between the library and the
    clients

  li Changing the library requires recompilation of the client code
  li 3rd party dependencies conflict
</code></pre>
<p>section
section
h2 Dynamic/Shared Libraries</p>
<p>p a single object file, that allows calling of predefined set of
| functions</p>
<p>section
h3 Pros
ul
li Almost complete isolation between library and client
li Changing the library without recompilation can be achieved</p>
<p>section
h3 Cons
ul
li Non standard
li A lot of platform specifics
li DLL boundary</p>
<p>section
section
h3 Symbol Visibility
ul
li Windows - hidden by default
li Others - visible by default</p>
<p>section
h4 Symbol Visibility
ul
li.fragment.fade-in Windows
:cxx
__declspec(dllimport)
:cxx
__declspec(dllexport)</p>
<pre><code>li.fragment.fade-in g++ / clang++
  code
    pre.
      // compile with flags
      -fvisibility=hidden -fvisibility-inlines-hidden
  :cxx
    __attribute__ ((visibility (&quot;default&quot;)))
</code></pre>
<p>section
:markdown
#### <code>dllimport</code> \ <code>dllexport</code>
:cxx
__declspec(dllexport) int answer = 42;</p>
<pre><code>__declspec(dllexport) int get_answer() {
  return 42;
}
</code></pre>
<p>section
:markdown
#### <code>dllimport</code> \ <code>dllexport</code>
:cxx
class __declspec(dllexport) Renderer {
public:
void render(const Texture&amp; texture);
};</p>
<pre><code>class Texture {
  public:
    __declspec(dllexport) void fill(Color color);

    void fill(byte r, byte g, byte b); // not exported
};
</code></pre>
<p>section
:markdown
#### <code>dllexport</code></p>
<pre><code>Makes symbols to be exported from the DLL - visible to clients
</code></pre>
<p>section
:markdown
#### <code>dllimport</code></p>
<pre><code>Makes symbols to be imported from a DLL, the linker is going to look
for these symbols in all linked DLLs
</code></pre>
<p>section
:markdown
#### <code>dllimport</code> \ <code>dllexport</code></p>
<pre><code>So the library needs to say `dllexport` and the client needs to
see `dllimport` for the same symbol
</code></pre>
<p>section
:markdown
### <code>MY_LIBRARY_API</code>
:cxx
#if defined(MY_LIBRARY_IMPL)
#define MY_LIBRARY_API __declspec(dllexport)
#else
#define MY_LIBRARY_API __declspec(dllimport)
#endif</p>
<pre><code>MY_LIBRARY_API int answer();
</code></pre>
<p>p.fragment.fade-in
:markdown
Compile the library with <code>MY_LIBRARY_IMPL</code> defined</p>
<p>section
:markdown
### <code>MY_LIBRARY_API</code>
:cxx
#if defined(_WIN32)
#define MY_LIBRARY_EXPORT __declspec(dllexport)
#define MY_LIBRARY_IMPORT __declspec(dllimport)
#else
#define MY_LIBRARY_EXPORT <strong>attribute</strong> ((visibility (&quot;default&quot;)))
#define MY_LIBRARY_IMPORT
#endif</p>
<pre><code>#if defined(MY_LIBRARY_IMPL)
  #define MY_LIBRARY_API MY_LIBRARY_EXPORT
#else
  #define MY_LIBRARY_API MY_LIBRARY_IMPORT
#endif
</code></pre>
<p>section
h3 Non-Windows &amp; 3rd party dependencies
p Controlling visibility of symbols - lack of internal linkage</p>
<p>section
h3 Symbol Maps
code
pre.
VERSION
{
global:
extern &quot;C++&quot; {
library*;
};
local: *;
};
p Link with:
code
pre.
-Wl,--version-script=library.map</p>
<p>section
h2 Lifetime of an application
.fragment.fade-in
Build
ol
li preprocess
li compile time
li link time
.fragment.fade-in
Execute
ol(start = 4)
li load time
li run time</p>
<p>section
h3 Linux
p Symbol resolution is done at load time, not at link time</p>
<p>section
ul
li.</p>
<pre><code>    undefined symbols in the library are reported when linking an
    executable, not the library itself

  li Symbols in the executable or a 3rd party library can override your
  own symbols

code.fragment.fade-in
  pre.
    # link with
    g++ *.o -Xlinker -Bsymbolic -o myLibrary.so
</code></pre>
<p>section</p>
<p>section
h2 API</p>
<p>section
:markdown
1. Pure <code>C</code>
2. <code>C++</code> with <code>std::</code></p>
<p>section
:markdown
### Pure <code>C</code> API</p>
<pre><code>Pros

* the most portable - `C` has no mangling
* easy to use with other languages
  * luajit's libffi (Foreign Function interface)
  * Python - ctype, cffi
  * C# (.NET) - PInvoke

Cons
  * `C` - no ``++`` features - resource management, OOP, generics 
  * prefix on every function
</code></pre>
<p>section
:markdown
### <em>Opaque Structure</em></p>
<p>:cxx
// just a forward declaration
typedef struct lua_State lua_State;
lua_State* lua_newstate();
void lua_call(lua_State* state, int arguments, int results);
void lua_close(lua_State*);</p>
<p>section
:markdown
### <code>C++</code> with <code>C</code> API</p>
<p>:cxx
typedef struct lua_State lua_State;
extern &quot;C&quot; lua_State* lua_newstate();
extern &quot;C&quot; {
int lua_compile(lua_State* state, const char* file);
int lua_run(lua_State* state, int);
}
:cxx
struct lua_State {
bool compile(const char* file);
} ;</p>
<pre><code>lua_State* lua_newstate() {
  return new lua_State;
}

int lua_compile(lua_State* state, const char* file) {
  return state-&gt;compile(file)? 1 : 0;
}
</code></pre>
<p>section
:markdown
### Having <code>std::</code> in the API</p>
<pre><code>* Works only for *header-only* libraries or libraries that are
  compiled by the user
* Or there must be a separate compiliant for each possible
  compiler / runtime / flags combination
</code></pre>
<p>section
:markdown
### <code>std::</code></p>
<pre><code>The standard doesn't define implementation details for the standard
library. So implementations may differ. For example:
</code></pre>
<p>section
:cxx
// GCC
class pseudo_vector {
T* begin;
T* end;
T* end_of_storage;
};</p>
<pre><code>// MSVS
class pseudo_vector {
  T* begin;
  T* end_of_storage;
  T* end;
};
</code></pre>
<p>section
:cxx
namespace library {
void add_random(std::vector&lt;int&gt;&amp; numbers) {
numbers.push_back(rand());
}
}</p>
<p>section
:markdown</p>
<pre><code>Implementation may be different when using different compiler options

Visual Studio has *debug iterators* enabled in *Debug* build. They
allow to detect incorrect usage of `STL`. For example, using an
iterator to a vector, after it has been invalidated.

In *Release* a `vector::iterator` can be a plain pointer, but a
*debug iterator* is actually a smart pointer
</code></pre>
<p>section
:markdown
### Memory allocation</p>
<pre><code> Allocated memory must be freed from the allocator that allocated it.

 * the library and the client *MUST* use the same allocator
 * the deallocation *MUST* happen in the same module as the
   corresponding allocation
</code></pre>
<p>section
:markdown
<code>STL</code> hides allocations from the user, so it impossible to be sure
that the memory will be deallocated from the allocator that allocated
it.</p>
<p>section
:markdown
## <em><code>C</code> with classes</em> / <em>COM</em></p>
<pre><code>* a `extern &quot;C&quot;` function that initializes the library and returns
  an object that implements the library interface
* functions and methods take only primitive types and pointers to
  interfaces
</code></pre>
<p>section
:markdown
#### Lua <em><code>C</code> with classes</em> style - declaration
:cxx
namespace Lua {
class State {
virtual void ~Lua() = 0;
virtual void destroy() = 0;
virtual bool compile(const char* file) = 0;
};
}
extern Lua::State* lua_new_state();</p>
<p>section
:markdown
#### Lua <em><code>C</code> with classes</em> style - implementation
:cxx
namespace Lua {</p>
<pre><code>  class StateImpl: public State {

    virtual void ~State() {
    }

    virtual void destroy() override {
      delete this;
    }

    virtual bool compile(const char* file) override {
      /...
    }
  };
}
</code></pre>
<p>section
:markdown
#### Lua <em><code>C</code> with classes</em> style - implementation
:cxx
Lua::State* lua_newstate() {
return new StateImpl;
}
namespace Lua {
void StateImpl::destroy() override {
delete this;
}
}
:markdown
Enforces that the <code>StateImpl</code> object is deallocated using the
allocator that allocated it</p>
<p>section
:markdown
#### Lua <em><code>C</code> with classes</em> style - client
:cxx
auto lua = lua_new_state();
lua-&gt;compile(&quot;hello.lua&quot;);
lua-&gt;destroy();</p>
<p>section
:markdown
#### Lua <em><code>C</code> with classes</em> style - resources
:cxx
struct LuaDestroyer {
void operator(Lua::State* lua) {
lua-&gt;destroy();
}
};</p>
<pre><code>std::unique_ptr&lt;Lua::State, LuaDestroyer&gt; lua(lua_new_state());
lua-&gt;compile(&quot;hello.lua&quot;);
</code></pre>
<p>section
:markdown
### Why not exporting the StateImpl class directly?
ul.fragment.fade-in
li Have to export all of its base classes and member types
li Exposes the implementation to the client. Client needs to be
| recompiled if the implementation changes
li Will work only with one compiler because of the different name
| mangling schemes</p>
<p>section
:markdown
### Why exporting an <em>abstract class</em> works</p>
<pre><code>An abstract class is just a virtual table - it matches the *COM*
model, and all compilers implement it in the same way.
</code></pre>
<p>section
:markdown
## Resources</p>
<pre><code>[HowTo: Export C++ classes from a DLL]
(http://www.codeproject.com/Articles/28969/HowTo-Export-C-classes-from-a-DLL)
</code></pre>
<p>section
section
:markdown
## pImpl</p>
<pre><code>*Pointer-to-Implementation* is a technique for reducing coupling
between a class (a library) and its clients
</code></pre>
<p>section
:markdown
### Pros</p>
<pre><code>* Allows the class implementation to change with recompiling the
  client
* Reducing compilation times by including *expensive* headers only in
  a single source file
</code></pre>
<p>section
:markdown
### Cons</p>
<pre><code>* Prevents function inlining 
* Adds an extra redirection for each call
</code></pre>
<p>section
:markdown
### Resources
* (A Twist on pImpl)[http://coherent-labs.com/a-twist-on-pimpl/]
* (A Twist on pImpl Gist)[https://gist.github.com/dimitarcl/3771331/]</p>
<p>section
:markdown
### Usage of pImpl</p>
<pre><code>Almost every project is divided in sub-projects according to some
principles. For example:
  * Implementation: separating platform specific code
  * Aspect: logging, profiling
  * Functionality: Rendering
</code></pre>
<p>section
:markdown
### Usage of pImpl</p>
<pre><code>*pImpl* can be used to implement the interfaces of the internal
libraries in a project
</code></pre>
</article><div class="row-fluid"><div class="col-md-12"><hr><ul class="pagination"><li><a href="/advanced-cpp/2017/03/13/errors/" title="Previous articles">&larr; Previous</a></li><li><a href="/advanced-cpp/2017/03/12/namespaces/" title="Next articles">Next &rarr;</a></li></ul></div></div></section></div><div class="col-sm-3"><nav role="navigation" class="navbar navbar-default"><div class="navbar-header"><div class="navbar-brand">Recent Posts</div></div><div class="clearfix"></div><ul class="nav navbar-stacked"><li><a href="/advanced-cpp/2017/05/01/allocators/">Memory management and allocators</a></li><li><a href="/advanced-cpp/2017/04/25/sample-tests/">Sample Test</a></li><li><a href="/advanced-cpp/2017/04/24/virtual/">Virtual functions and inheritance</a></li><li><a href="/advanced-cpp/2017/04/19/midterm-test/">Midterm test</a></li><li><a href="/advanced-cpp/2017/04/14/algorithms/">STL Algorithms</a></li><li><a href="/advanced-cpp/2017/04/11/iterators/">STL Iterators</a></li><li><a href="/advanced-cpp/2017/04/04/containers/">STL Containers</a></li><li><a href="/advanced-cpp/2017/03/27/templates/">Templates</a></li></ul></nav></div></div><footer id="page-footer"><footer><div class="row-fluid"><div class="col-md-12"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" width="88px" height="31px" src="/advanced-cpp/images/cc-by-sa.png"></a><br><span>Advanced C++</span> by<span> SofiaC++</span> is licensed under a&nbsp;<a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International
License
</a></div></div></footer><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/bower_components/bootstrap/dist/js/bootstrap.min.js"></script><script src="/advanced-cpp/snippet.js"></script></footer></div></body></html>