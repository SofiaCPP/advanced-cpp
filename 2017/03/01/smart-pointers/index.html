<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="SofiaC++"><meta name="description"><title>Smart Pointers&mdash;Advanced C++</title><link href="/advanced-cpp/favicon.png" rel="icon"><link rel="alternate" href="/advanced-cpp/atom.xml" title="config.title" type="application/atom.xml"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet"><link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css" rel="stylesheet"><style>body { padding-top: 50px; }</style></head><body><div class="container"><nav role="navigation" class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Advanced C++</a></div><div id="navbar" class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href="/advanced-cpp/categories/news/">News</a></li><li><a href="/advanced-cpp/categories/slides/">Slides</a></li><li><a href="/advanced-cpp/about/">About</a></li></ul></div></div></nav><div class="page-header"><h1><a href="/advanced-cpp/">Advanced C++</a></h1><p id="site-slogan">Site for the Advanced C++ course at FMI</p></div><div class="row"><div class="col-sm-9"><section id="content"><article class="post"><h2>Smart Pointers</h2><div class="meta">01 Mar 2017 in <a href="/advanced-cpp/categories/slides/">slides</a>&ensp;</div><a href="/advanced-cpp/slides/05_smartptr.html" class="btn btn-large btn-primary">Slide Show</a><section><h1>Smart Pointers</h1>
</section><section><h2>Contents</h2>
<ul>
<li>What is a <em>smart pointer</em></li>
<li><code>std::auto_ptr</code></li>
<li><code>std::unique_ptr</code></li>
<li>reference counting</li>
<li><code>std::shared_ptr</code></li>
<li>other smart pointers</li>
</ul>
</section><section><h2>What is a <em>smart pointer</em></h2>
<p>Object that behaves as a pointer by overloading <code>operator*()</code>
and <code>operator-&gt;()</code></p>
</section><section><pre><code>// the simplest SmartPointer
template &lt;typename T&gt;
class SmartPointer
{
    public:
        T* operator-&gt;()
        {
            return m_Pointer;
        }

        T&amp; operator* ()
        {
            return *m_Pointer;
        }
    private:
        T* m_Pointer;
};
</code></pre>
</section><section><h2><code>operator-&gt;()</code></h2>
<p>Every time the compiler evaluates the <code>-&gt;</code> operator, until the right
side of the operator becomes a native pointer.</p>
</section><section><h2>What are smart pointers useful for?</h2>
<ul>
<li>Managing resources</li>
<li>Expressing ownership semantic</li>
</ul>
</section><section><h2>Standard smart pointers</h2>
<ul>
<li><code>std::auto_ptr</code></li>
<li><code>std::unique_ptr</code></li>
<li><code>std::shared_ptr</code></li>
<li><code>std::weak_ptr</code></li>
<li><code>boost::intrusive_ptr</code></li>
</ul>
</section><section><section><h2><code>std::auto_ptr</code></h2>
<p>A smart pointer that frees the memory upon destruction.  In C++ 11 it was
removed from the language. It is fully replaced by <code>std::unique_ptr</code>
without any drawbacks</p>
</section><section><h2>A simplified implementation of <code>std::auto_ptr</code></h2>
</section><section><h2>The &quot;smart pointer&quot; part</h2>
<div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/auto_ptr.hxx" data-sections="header smart_ptr footer"><pre><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-built_in">auto_ptr</span> {
<span class="hljs-comment">// ...</span>
T* <span class="hljs-keyword">operator</span>-&gt;()
{
	<span class="hljs-keyword">return</span> m_Pointer;
}

T&amp; <span class="hljs-keyword">operator</span>* ()
{
	<span class="hljs-keyword">return</span> *m_Pointer;
}
<span class="hljs-comment">// ...</span>
T* m_Pointer;
};</code></pre></div></section><section><h2>The RAII part</h2>
<div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/auto_ptr.hxx" data-sections="header RAII footer"><pre><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-built_in">auto_ptr</span> {
<span class="hljs-comment">// ...</span>
<span class="hljs-built_in">auto_ptr</span>()
	: m_Pointer(<span class="hljs-literal">nullptr</span>)
{}

<span class="hljs-built_in">auto_ptr</span>(T* pointer)
	: m_Pointer(pointer)
{}

~<span class="hljs-built_in">auto_ptr</span>()
{
	<span class="hljs-keyword">delete</span> m_Pointer;
}
<span class="hljs-comment">// ...</span>
T* m_Pointer;
};</code></pre></div></section><section><h2>The bad parts</h2>
<div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/auto_ptr.hxx" data-sections="header copy-assign footer"><pre><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-built_in">auto_ptr</span> {
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">// copy ctor changes the original!!!</span>
<span class="hljs-built_in">auto_ptr</span>(<span class="hljs-built_in">auto_ptr</span>&amp; o) : m_Pointer(o.m_Pointer) {
	o.m_Pointer = <span class="hljs-literal">nullptr</span>;
}

<span class="hljs-comment">// assignment changes the original!!!</span>
<span class="hljs-built_in">auto_ptr</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">auto_ptr</span>&amp; rhs) {
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) {
		<span class="hljs-keyword">delete</span> m_Pointer;
		m_Pointer = rhs.m_Pointer;
		rhs.m_Pointer = <span class="hljs-literal">nullptr</span>;
	}
	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
<span class="hljs-comment">// ...</span>
T* m_Pointer;
};</code></pre></div></section><section><p>Due to the lack of move semantics in C++ 98, <code>std::auto_ptr</code> is forced
to transfer the ownership of the pointer during copy construction and
assignment. <code>std::auto_ptr</code> was also copiable and assignable. You could
make a <code>std::vector&lt;std::auto_ptr&gt;</code>, but it would be completely
unpredictable - the standard does not require certain copy/assignment
guarantees for containers.</p>
</section></section><section><section><h2><code>std::unique_ptr</code></h2>
<p>C++ 11 introduces <code>std::unique_ptr</code></p>
<ul>
<li>it is not copyable</li>
<li>it is moveable</li>
</ul>
</section><section><h2>A simplified implementation of <code>std::unique_ptr</code></h2>
</section><section><h2>The &quot;smart pointer&quot; part</h2>
<div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/unique_ptr.hxx" data-sections="header smart_ptr footer"><pre><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> unique_ptr {
<span class="hljs-comment">// ...</span>
T* <span class="hljs-keyword">operator</span>-&gt;()
{
    <span class="hljs-keyword">return</span> m_Pointer;
}

T&amp; <span class="hljs-keyword">operator</span>* ()
{
    <span class="hljs-keyword">return</span> *m_Pointer;
}
<span class="hljs-comment">// ...</span>
T* m_Pointer;
};</code></pre></div></section><section><h2>The RAII part</h2>
<div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/unique_ptr.hxx" data-sections="header RAII footer"><pre><code>template &lt;typename T&gt;
struct unique_ptr {
<span class="hljs-comment">// ...</span>
<span class="hljs-function">unique_ptr</span>()
    <span class="hljs-value">: <span class="hljs-function">m_Pointer</span>(nullptr)
{}

<span class="hljs-function">unique_ptr</span>(T* pointer)
    : <span class="hljs-function">m_Pointer</span>(pointer)
{}

~<span class="hljs-function">unique_ptr</span>()
{
    delete m_Pointer;</span>
}
<span class="hljs-comment">// ...</span>
T* m_Pointer;
};</code></pre></div></section><section><h2>The non-copyable part</h2>
<div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/unique_ptr.hxx" data-sections="header copy footer"><pre><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> unique_ptr {
<span class="hljs-comment">// ...</span>
unique_ptr(<span class="hljs-keyword">const</span> unique_ptr&amp; o) = <span class="hljs-keyword">delete</span>;
unique_ptr&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-keyword">const</span> unique_ptr&amp; rhs) = <span class="hljs-keyword">delete</span>;
<span class="hljs-comment">// ...</span>
T* m_Pointer;
};</code></pre></div></section><section><h2>The move part</h2>
<div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/unique_ptr.hxx" data-sections="header move footer"><pre><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> unique_ptr {
<span class="hljs-comment">// ...</span>
unique_ptr(unique_ptr&amp;&amp; o)
    : m_Pointer(o.m_Pointer)
{
    o.m_Pointer = <span class="hljs-literal">nullptr</span>;
}

unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&amp;&amp; rhs)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) {
        <span class="hljs-keyword">delete</span> m_Pointer;
        m_Pointer = rhs.m_Pointer;
        rhs.m_Pointer = <span class="hljs-literal">nullptr</span>;
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
<span class="hljs-comment">// ...</span>
T* m_Pointer;
};</code></pre></div></section><section><h4><code>std::unique_ptr&lt;T&gt;</code> synopsis</h4>
<ul>
<li><code>unique_ptr()</code> default constructor</li>
<li><code>unique_ptr(Y*)</code> constructor - allows using pointers to
<code>Derived</code> classes to be hold in <code>std::unique_ptr&lt;Base&gt;</code></li>
</ul>
</section><section><ul>
<li><code>T&amp; operator* ()</code></li>
<li><code>T* operator-&gt; ()</code></li>
<li><code>const T&amp; operator* () const</code></li>
<li><code>const T* operator-&gt; () const</code></li>
<li><code>T* get()</code> - get the underlying pointer</li>
<li><code>const T* get() const</code></li>
</ul>
</section><section><ul>
<li>
<p><code>T* release()</code> - get the underlying pointer and release
ownership over it. Use it when you need to give up the ownership of the
resource</p>
</li>
<li>
<p><code>void reset(T* new_pointer = nullptr)</code> - reset the underlying
pointer to <code>new_pointer</code> and get ownership over it. Deletes the
current pointer.</p>
</li>
</ul>
</section><section><p><code>explicit operator bool()</code> allows usage such as</p>
<pre><code>std::unique_ptr&lt;T&gt; p;
if (p) {
    std::cout &lt;&lt; *p &lt;&lt; std::endl;
}
</code></pre>
</section><section><p><code>std::unique_ptr</code> has a second template parameter</p>
<pre><code>template &lt;typename T, typename Deleter = std::default_delete&lt;T&gt;&gt;
class unique_ptr
{
    ~unique_ptr() {
        auto deleter = get_deleter();
        deleter(m_Pointer);
    }
};
</code></pre>
</section><section><h2>Bad</h2>
<div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/unique_array.cxx" data-sections="bad"><pre><code><span class="hljs-symbol">std:</span><span class="hljs-symbol">:unique_ptr&lt;Lifetime&gt;</span> a(new <span class="hljs-constant">Lifetime[</span><span class="hljs-number">2</span>]);
<span class="hljs-regexp">//std</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:cout</span> &lt;&lt; <span class="hljs-string">"Second: "</span> &lt;&lt; &amp;a[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-symbol">std:</span><span class="hljs-symbol">:endl</span>;</code></pre></div><p>Will make a <code>delete</code> to memory allocated with <code>new []</code></p>
</section><section><h2>Good</h2>
<div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/unique_array.cxx" data-sections="good"><pre><code><span class="hljs-built_in">std</span>::unique_ptr&lt;Lifetime[]&gt; a(<span class="hljs-keyword">new</span> Lifetime[<span class="hljs-number">2</span>]);
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Second: "</span> &lt;&lt; &amp;a[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">std</span>::endl;</code></pre></div></section><section><p><code>T&amp; operator[](size_t index)</code> - allows array element access.  Only
<code>std::unique_ptr&lt;T[]&gt;</code> has this method.</p>
</section><section><h2>Custom deleter</h2>
<pre><code>struct ReleaseDelete {
    template &lt;typename T&gt;
    void operator()(T* pointer) {
        pointer-&gt;Release();
    }
};

// ...
std::unique_ptr&lt;ID3D11Device, ReleaseDelete&gt; device;
</code></pre>
</section><section><p>Will be back to <code>unique_ptr</code> deleter when we get to:</p>
<ul>
<li>template typedefs</li>
<li>template specialization</li>
</ul>
</section><section><h2><code>std::unique_ptr</code> owns the resource it is pointing to</h2>
<p>Use this to express ownership relation between types</p>
</section></section><section><section><h2><code>std::shared_ptr</code></h2>
<p><code>std::shared_ptr</code> allows sharing of a resource. It is freed when the
last <code>std::shared_ptr</code> instance pointing to the resource is destroyed.
<code>std::shared_ptr</code> uses <a href="http://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="external">Reference
Counting</a>.</p>
</section><section><h2>Reference counting</h2>
<p>A technique of storing the number of references, pointers, or handles to a
resource.</p>
<p>A garbage collection algorithm that uses these reference counts to
deallocate objects which are no longer referenced</p>
</section><section><h2>Reference counting</h2>
<p><img src="/advanced-cpp/slides/05_smartptr/RC.svg" alt="Reference counting"></p>
</section><section><h4>Reference counting</h4>
<pre><code>std::shared_ptr&lt;int&gt; t(new int(42));// pointer 0xff00 : rc 1
std::shared_ptr&lt;int&gt; q = t;         // pointer 0xff00 : rc 2
std::shared_ptr&lt;int&gt; p(new int(24));// pointer 0xfe00 : rc 1

t = p;  // pointer 0xff00 : rc 1
        // pointer 0xfe00 : rc 2
        
q = t;  // pointer 0xff00 : rc 0, so it is deleted
        // pointer 0xfe00 : rc 3
</code></pre>
</section><section><h4>Implementation of <code>std::shared_ptr</code></h4>
<p>The <em>reference count</em> and the <em>resource</em> need to be shared between all
instances. So they have to be on the heap.</p>
</section><section><div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/shared_ptr.hxx" data-sections="ctor dtor member"><pre><code><span class="hljs-function">SharedPtr</span>()
    <span class="hljs-value">: <span class="hljs-function">m_RC</span>(nullptr)
    , <span class="hljs-function">m_Pointer</span>(nullptr)
{}

<span class="hljs-function">SharedPtr</span>(T* pointer)
    : <span class="hljs-function">m_RC</span>(new <span class="hljs-function">int</span>(<span class="hljs-number">1</span>))
    , <span class="hljs-function">m_Pointer</span>(pointer)
{
}
// ...
~<span class="hljs-function">SharedPtr</span>()
{
    <span class="hljs-function">RemoveReference</span>();</span>
}
<span class="hljs-comment">// ...</span>
int* m_RC;
T* m_Pointer;</code></pre></div></section><section><div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/shared_ptr.hxx" data-sections="RC"><pre><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RemoveReference</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">if</span> (m_RC &amp;&amp; --*m_RC == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">delete</span> m_Pointer;
        <span class="hljs-keyword">delete</span> m_RC;
    }
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddReference</span><span class="hljs-params">()</span>
</span>{
    ++*m_RC;
}</code></pre></div></section><section><div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/shared_ptr.hxx" data-sections="copy"><pre><code>SharedPtr(<span class="hljs-keyword">const</span> SharedPtr&amp; o)
    : m_RC(o.m_RC)
    , m_Pointer(o.m_Pointer)
{
    AddReference();
}

SharedPtr&amp; operator=(<span class="hljs-keyword">const</span> SharedPtr&amp; rhs)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs)
    {
        RemoveReference();
        m_RC = rhs.m_RC;
        m_Pointer = rhs.m_Pointer;
        AddReference();
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}</code></pre></div></section><section><div class="snippet" data-file="/advanced-cpp/slides/05_smartptr/shared_ptr.hxx" data-sections="move"><pre><code>SharedPtr(SharedPtr&amp;&amp; o)
    : m_RC(o.m_RC)
    , m_Pointer(o.m_Pointer)
{
    o.m_RC = <span class="hljs-literal">nullptr</span>;
    o.m_Pointer = <span class="hljs-literal">nullptr</span>;
}

SharedPtr&amp; <span class="hljs-keyword">operator</span>=(SharedPtr&amp;&amp; rhs)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) {
        RemoveReference();
        m_RC = rhs.m_RC;
        m_Pointer = rhs.m_Pointer;
        rhs.m_RC = <span class="hljs-literal">nullptr</span>;
        rhs.m_Pointer = <span class="hljs-literal">nullptr</span>;
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}</code></pre></div></section><section><h3><code>shared_ptr</code> is for sharing</h3>
<p>Use a <code>shared_ptr</code> to express that the ownership of the resource is shared.</p>
</section><section><h3>Reference Counting and cycles</h3>
<p>If you have a cycle in the references between resources in
<code>std::shared_ptr</code>, these resources will never be freed.</p>
</section><section><h3>How to handle cyclic references?</h3>
<ul>
<li>manually by breaking the cycle</li>
<li>use <em>weak</em> references</li>
</ul>
</section><section><h4><code>std::weak_ptr</code></h4>
<p><em>Weak</em> references point to a resource, but do not prolong its lifetime.</p>
</section><section><pre><code>std::weak_ptr&lt;int&gt; w;
{
    std::shared_ptr&lt;int&gt; s = std::make_shared&lt;int&gt;(42);
    w = s;
}
if (auto pointer = w.lock()) {
    std::cout &lt;&lt; *pointer &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; &quot;It's gone&quot; &lt;&lt; std::endl;
}
</code></pre>
</section><section><pre><code>template &lt;typename T&gt;
class weak_ptr {
    // ...
    shared_ptr lock() {
        if (&lt;It is still alive&gt;) {
            return shared_ptr&lt;T&gt;(&lt;for It&gt;);
        }
        return shared_ptr();
    }
};
</code></pre>
</section><section><section><h2>So how does <code>shared_ptr</code> work?</h2>
</section></section><section><h3>Where is the reference count stored?</h3>
<ul>
<li>as a member in the <code>shared_ptr</code>?</li>
<li>as a static member in <code>shared_ptr&lt;T&gt;</code>?</li>
</ul>
</section><section><h4>As a member?</h4>
<pre><code>std::shared_ptr&lt;int&gt; q;
{
    std::shared_ptr&lt;int&gt; p = std::make_shared&lt;int&gt;(42);
    q = p;
    // p gets destroyed here, but it can't reach within q
    // unless an expensive list of shared_ptr is stored
    // somewhere
}
</code></pre>
</section><section><h4>As a static member?</h4>
<pre><code>std::shared_ptr&lt;int&gt; p = std::make_shared&lt;int&gt;(42);
std::shared_ptr&lt;int&gt; q = std::make_shared&lt;int&gt;(42);
// oops, p and q have reference count 2, but actually point to
// different resources
</code></pre>
</section><section><h4>In the heap as a shared object</h4>
<p><img src="/advanced-cpp/slides/05_smartptr/shared_pointer.svg" alt="Shared Ptr"></p>
</section><section><h4><code>shared_ptr</code> price</h4>
<ul>
<li>double indirection
<ul>
<li>can be optimized with a little higher memory usage</li>
</ul>
</li>
<li>extra memory allocation
<ul>
<li>worse - it is a small memory allocation, which are most wasteful</li>
</ul>
</li>
</ul>
</section><section><h3>Use <code>std::make_shared</code></h3>
<ul>
<li>allocates a single block for object and reference count
<ul>
<li>the object is inplace constructed in the block</li>
<li>better <em>cache locality</em></li>
</ul>
</li>
</ul>
<p><img src="/advanced-cpp/slides/05_smartptr/make_shared.svg" alt="Make Shared"></p>
</section></section><section><section><h2><em>Intrusive</em> reference counting</h2>
<p>The reference count is stored in the resource (object) itself.</p>
<p><img src="/advanced-cpp/slides/05_smartptr/intrusive.svg" alt="Intrusive"></p>
</section><section><h3><code>boost::intrusive_ptr</code></h3>
<ul>
<li>
<p>add a reference - calls <code>intrusive_ptr_add_ref(T*)</code></p>
</li>
<li>
<p>release a reference - calls <code>intrusive_ptr_release(T*)</code></p>
<p>class Renderer;</p>
<p>void intrusive_ptr_add_ref(Renderer* r) {
++r-&gt;refs;
}</p>
<p>void intrusive_ptr_release(Renderer* r) {
if (--r-&gt;refs == 0) {
delete r;
}
}</p>
</li>
</ul>
</section><section><h3>When to use <code>intrusive_ptr</code>?</h3>
<ul>
<li>some external APIs are already reference counted
<ul>
<li>OS, other languages</li>
</ul>
</li>
<li>more memory efficient than <code>shared_ptr</code></li>
</ul>
</section><section><h3><code>std???::intrusive_ptr</code></h3>
<p>There is no <code>std::intrusive_ptr</code> class, because <code>std::make_shared</code> gives you
almost the same thing.</p>
</section><section><h3><em>Almost</em>?</h3>
<p>Using an <code>intrusive_ptr</code> allows you to temporary give up
using smart pointers, go down to <code>C</code> pointer and then go up
to an <code>intrusive_ptr</code></p>
</section><section><h3><code>std::enable_shared_from_this&lt;T&gt;</code></h3>
<ul>
<li>allows creating a <code>shared_ptr</code> from <code>this</code>.</li>
<li><strong>requires</strong> that there is at least one shared_ptr pointing
to the object</li>
<li>works by having a <code>std::weak_ptr</code> inside the object for the
object itself</li>
</ul>
</section><section><pre><code>class Renderer : public std::enable_shared_from_this&lt;Renderer&gt;
{
};

std::shared_ptr&lt;Renderer&gt; get_the_shared_ptr(Renderer* r)
{
    return r-&gt;shared_from_this();
}
</code></pre>
</section></section><section><h2>No plain <code>new</code></h2>
<ul>
<li><code>std::make_shared&lt;T&gt;</code> is the best way to create a shared pointer</li>
<li><code>C++</code>14 - <code>std::make_unique&lt;T&gt;</code> - creates an unique pointer</li>
</ul>
</section><section><h2>Other smart pointers</h2>
<ul>
<li><a href="https://github.com/facebook/folly" target="_blank" rel="external">Facebook log and leak</a>
<ul>
<li>use 15 counts and when it reaches 16, log and leave it to leak</li>
</ul>
</li>
<li><a href="https://cs.chromium.org/chromium/src/base/memory/linked_ptr.h" target="_blank" rel="external"><code>link_ptr</code></a></li>
</ul>
</section></article><div class="row-fluid"><div class="col-md-12"><hr><ul class="pagination"><li><a href="/advanced-cpp/2017/03/05/smart-resources/" title="Previous articles">&larr; Previous</a></li><li><a href="/advanced-cpp/2017/02/28/resources/" title="Next articles">Next &rarr;</a></li></ul></div></div></section></div><div class="col-sm-3"><nav role="navigation" class="navbar navbar-default"><div class="navbar-header"><div class="navbar-brand">Recent Posts</div></div><div class="clearfix"></div><ul class="nav navbar-stacked"><li><a href="/advanced-cpp/2017/05/22/multithreading/">Multithreading and Concurrent programming</a></li><li><a href="/advanced-cpp/2017/05/21/midterm-results/">Midterm Test Results</a></li><li><a href="/advanced-cpp/2017/05/12/midterm-test-2/">Midterm test</a></li><li><a href="/advanced-cpp/2017/05/01/allocators/">Memory management and allocators</a></li><li><a href="/advanced-cpp/2017/04/25/sample-tests/">Sample Test</a></li><li><a href="/advanced-cpp/2017/04/24/virtual/">Virtual functions and inheritance</a></li><li><a href="/advanced-cpp/2017/04/19/midterm-test/">Midterm test</a></li><li><a href="/advanced-cpp/2017/04/14/algorithms/">STL Algorithms</a></li></ul></nav></div></div><footer id="page-footer"><footer><div class="row-fluid"><div class="col-md-12"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" width="88px" height="31px" src="/advanced-cpp/images/cc-by-sa.png"></a><br><span>Advanced C++</span> by<span> SofiaC++</span> is licensed under a&nbsp;<a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International
License
</a></div></div></footer><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/bower_components/bootstrap/dist/js/bootstrap.min.js"></script><script src="/advanced-cpp/snippet.js"></script></footer></div></body></html>