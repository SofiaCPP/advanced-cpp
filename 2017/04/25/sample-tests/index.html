<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="SofiaC++"><meta name="description"><title>Sample Test&mdash;Advanced C++</title><link href="/advanced-cpp/favicon.png" rel="icon"><link rel="alternate" href="/advanced-cpp/atom.xml" title="config.title" type="application/atom.xml"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet"><link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css" rel="stylesheet"><style>body { padding-top: 50px; }</style></head><body><div class="container"><nav role="navigation" class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Advanced C++</a></div><div id="navbar" class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href="/advanced-cpp/categories/news/">News</a></li><li><a href="/advanced-cpp/categories/slides/">Slides</a></li><li><a href="/advanced-cpp/about/">About</a></li></ul></div></div></nav><div class="page-header"><h1><a href="/advanced-cpp/">Advanced C++</a></h1><p id="site-slogan">Site for the Advanced C++ course at FMI</p></div><div class="row"><div class="col-sm-9"><section id="content"><article class="post"><h2>Sample Test</h2><div class="meta">25 Apr 2017</div><p>Please, keep in mind that the content of the course is different, so some
of the questions are not and will not be covered at all.
</p><ol><li>При кое извикване на функция/метод ще се използва Argument Dependent
Lookup?<ol type="a"><li>::f(a);</li><li>a.f(b);</li><li>Lib::f(a);</li><li>f(a)</li></ol></li><li>При дадените декларации:<code><pre>class Base { } ;
class Der : public Base { } ;

void f(const Base& o);
template <typename t=""> f(const T& o);

Der d;
</typename></pre></code>Обръщението f(d) e:<ol type="a"><li>Обръщение към void f(const Base& o)</li><li>Обръщение към void f<derived>(const Derived& o)</derived></li><li>Компилационна грешка - неопределено</li><li>Грешка по време на изпълниение</li></ol></li><li>На какво разчита RAII (Resource Acquisition Is Initialization) за да
осигури придобиването и освобождаването на ресурса съответно?<ol type="a"><li>на явно извикване на методи</li><li>на конструктора и деструктора</li><li>на използването на умен указател</li></ol></li><li>Използването на shared_ptr има смисъл само при multithreaded
приложения?<ol type="a"><li>вярно</li><li>не вярно</li></ol></li><li>При използването на operator-> на умен указател, operator-> се
прилага:<ol type="a"><li>един път</li><li>докато се стигне до обикновен указател</li></ol></li><li>На какво разчита std::binary_search(begin, end) за да работи?<ol type="a"><li>[begin, end) да е сортирана редица и елементите и да имат
operator==
</li><li>[begin, end) да е сортирана редица и елементите и да имат
operator<
</li><li>[begin, end) да е произволна редица и елементите и да имат
operator<
</li><li>[begin, end) да е произволна редица и елементите и да имат
operator==
</li></ol></li><li>Кой алгоритъм бихте използвали за извеждане на десетте най-добри
резултата в намаляващ ред?<ol type="a"><li>std::sort</li><li>std::nth_element</li><li>std::partial_sort</li><li>собствен алгоритъм</li></ol></li><li>При следните декларации:<code><pre>template <typename t=""> void f(const T& x);
template <typename t=""> void f(const std::vector<t>& x);
void f(const std::vector<int>& x);

typedef std::vector<int> VectorInt;
VectorInt x;
</int></int></t></typename></typename></pre></code></li>Обръщението f(x) ще извика:<ol type="a"><li>f(const T& x)</li><li>f(const std::vector<t>& x)</t></li><li>f(const std::vector<int>& x)</int></li></ol><li>Виртуалното наследяване е част от поддръжката на C++ за<ol type="a"><li>виртуални методи</li><li>generic programming</li><li>множествено наследяване</li><li>обектно-ориентирано програмиране</li></ol></li><li>Точка на инстацииране наричаме:<ol type="a"><li>мястото на създаване на обект</li><li>мястото на декларация на шаблон</li><li>мястото на дефиниция на шаблон</li><li>мястото на използване на шаблон</li></ol></li><li>Кои методи на шаблон се инстанциират при използването на lazy
instantiation в рамките на един translation unit и видима дефиниция
на шаблона?<ol type="a"><li>всички, които се използват</li><li>всички</li><li>никой - методите се генерират веднъж за цялото приложение</li><li>само тези които явно укажем</li></ol></li><li>Кога се извършва name lookup за използваните функции независещи от
шаблонен аргумент в даден шаблон?<ol type="a"><li>при декларацията на шаблона</li><li>при дефиницията на шаблона</li><li>при инстанциирането на шаблона</li></ol></li><li>weak_ptr<ol type="a"><li>нормален указател</li><li>умен указател, правещ reference count и освобождаващ ресурса,
когато не е нужен
</li><li>умен указател, сочещ към споделен ресурс, без да се брои като
reference
</li></ol></li><li>Ако има нещо нередно със следния код, как бихте го поправили?<code><pre>struct Base
{
    void f(int);
}
struct Der : Base
{
    void f(const vector<int>&);
}

Der d;
d.f(42);
</int></pre></code></li><li>Къде може да ползвате „безопасно“ виртуални функции?<ol type="a"><li>само извън класа</li><li>извън класа и в неговите методи</li><li>навсякъде с изключение на инициализиащия списък на базовите
класове</li></ol></li><li>Ако има нещо нередно със следния код, как бихте го поправили?<code><pre>bool print(int x) { cout << x; }
vector<int> v(10);
// v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
vector<int> x;
std::copy(v.begin(), v.end(), x.begin());
std::for_each(x.begin(), x.end(), print);
</int></int></pre></code></li></ol></article><div class="row-fluid"><div class="col-md-12"><hr><ul class="pagination"><li><a href="/advanced-cpp/2017/05/01/allocators/" title="Previous articles">&larr; Previous</a></li><li><a href="/advanced-cpp/2017/04/24/virtual/" title="Next articles">Next &rarr;</a></li></ul></div></div></section></div><div class="col-sm-3"><nav role="navigation" class="navbar navbar-default"><div class="navbar-header"><div class="navbar-brand">Recent Posts</div></div><div class="clearfix"></div><ul class="nav navbar-stacked"><li><a href="/advanced-cpp/2017/05/22/multithreading/">Multithreading and Concurrent programming</a></li><li><a href="/advanced-cpp/2017/05/21/midterm-results/">Midterm Test Results</a></li><li><a href="/advanced-cpp/2017/05/12/midterm-test-2/">Midterm test</a></li><li><a href="/advanced-cpp/2017/05/01/allocators/">Memory management and allocators</a></li><li><a href="/advanced-cpp/2017/04/25/sample-tests/">Sample Test</a></li><li><a href="/advanced-cpp/2017/04/24/virtual/">Virtual functions and inheritance</a></li><li><a href="/advanced-cpp/2017/04/19/midterm-test/">Midterm test</a></li><li><a href="/advanced-cpp/2017/04/14/algorithms/">STL Algorithms</a></li></ul></nav></div></div><footer id="page-footer"><footer><div class="row-fluid"><div class="col-md-12"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" width="88px" height="31px" src="/advanced-cpp/images/cc-by-sa.png"></a><br><span>Advanced C++</span> by<span> SofiaC++</span> is licensed under a&nbsp;<a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International
License
</a></div></div></footer><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/bower_components/bootstrap/dist/js/bootstrap.min.js"></script><script src="/advanced-cpp/snippet.js"></script></footer></div></body></html>