title: Sample Test
date: 2015-05-03 00:15:20
tags: test
---
ol.test
    li (1) Кога ще се унищожи променливата а?
        :cxx
            if (auto a = answer()) { // 1
            } else { // 2
            } // 3
        ul.choice.inline
            li 1
            li 2
            li 3

    li (2) Кога се създава и унищожава член променливата 
        code m_Name 
        | спрямо създаването на инстанция на Person?
        :cxx
            struct Person {
                Person(const char* name)
                // 1
                {
                    m_Name = name; // 2
                } // 3
                ~Person()
                // 4
                {
                  // 5
                } // 6
            };
        p Създава:
            ul.choice.inline
                li 1
                li 2
                li 3
        p Унищожава:
            ul.choice.inline
                li 4
                li 5
                li 6

    li (5) Има ли нещо нередно в този код? Ако да - как бихте го
        | оправили?
        :cxx
            struct RenderTarget {
                RenderTarget(int width, int height) {
                    auto size = width * height;
                    m_BackBuffer = new Color[size];
                    m_DepthBuffer = new float[size];
                }
                ~RenderTarget() {
                    delete [] m_BackBuffer;
                    delete [] m_DepthBuffer;
                }
                Color* m_BackBuffer;
                float* m_DepthBuffer;
            };

    li (1) Какъв ще е типът на променливата 
        code splash
        | ?
        :cxx
            const Image& Load(const char*);
            // ...
            auto splash = Load("splash.png");
        ul.choice.inline
            li
                code Image
            li
                code const Image&
            li
                code object
            li Не се компилира

    li (1) Как бихме могли да вземем референция към обект използвайки 
        code auto
        | ?

    li (2) Какво представлява sink функцията?
        ul.choice
            li унищожава аргументите си
            li копира аргументите си в променливи, чиито scope
                | продължава след приключването на функцията
            li няма странични ефекти

    li (1) Изпълнява ли се деструктора на обекти, чиито данни са били
        | преместени в други инстанции на същия клас?
        ul.choice.inline
            li Да
            li Не

    li (1) Какво прави 
        code std::move 
        | ?
        ul.choice.inline
            li мести данни из паметта
            li създава r-value reference от value
            li създава value от r-value reference

    li (8)(16) Трябва да напишете клас 
        code Image, 
        | който съдържа буфер с байтове. Напишете декларациите на
        | конструктурите, деструктурите, операторите и член данните,
        | които класът ще има.

    li (2) Как е най-ефективно да предаваме аргументи на sink функция?
        ul.choice.inline
            li по адрес, чрез указател
            li по r-value reference
            li по константен псевдоним
            li по стойност

    li (8) Напишете клас, който съдържа 
        code FILE*
        | и се грижи за затварянето на файла.

    li (1) Каква семантика за собственост показва 
        code T* pointer
        ul.choice.inline
            li Никаква
            li за собственост
            li за споделена собственост

    li (1) Каква семантика за собственост показва 
        code std::unique_ptr<T> pointer
        ul.choice.inline
            li Никаква
            li за собственост
            li за споделена собственост

    li (1) Каква семантика за собственост показва 
        code std::shared_ptr<T> pointer
        ul.choice.inline
            li Никаква
            li за собственост
            li за споделена собственост

    li (2) Защо е по-добре да ползваме 
        code std::make_shared&lt;T&gt;(42) 
        | вместо 
        code std::shared_ptr&lt;T&gt; p(new T(42)) 

    li (4) Кои оператори трябва да предефинира един добър клас за умен
        | указател?
        ul.choice
            li
                code.
                    T& operator*();
            li
                code.
                    T* operator->();
            li
                code.
                    T& operator*() const;
            li
                code.
                    T* operator->() const;
            li
                code.
                    operator bool() const;
            li
                code.
                    explicit operator bool() const;

    li (4) Ползвате библиотека за работа с изображения, предоставяща
        | следния интерфейс:

        :cxx
            struct Image {
                /// destroy this image
                virtual void Destroy() = 0;
            };
            /// creates a new image from file
            Image* LoadImage(const char* path);

        | Как бихте ползвали тази библиотека със 
        code std::shared_ptr
        | ?

    li (2) Какво прави компилаторът, когато види 
        code p->method() 
        | ?
        ul.choice
            li Дава грешка, ако 
                code p 
                | не е указател
            li Изпълнява 
                code operator->() 
                | докато не стигне до обикновен указател
            li Изпълнява 
                code operator->() 
                | и очаква резултатът да е обикновен указател

    li (2) Какво ще направи следния фрагмент?
        :cxx
            namespace sql {
                struct Query {
                    std::string& statement() const;
                };
                std::ostream& operator<<(std::ostream& output,
                        const Query& query) {
                    return output << query.statement();
                }
            }

            int main () {
                std::Query query;
                std::cout << query << std::endl;
                return 0;
            }
        ul.choice.inline
            li няма да се компилира
            li undefined behavior
            li ще изведе адреса на query
            li ще изведе заявката

    li (2) Има ли нещо нередно в следния фрагмент. Ако да - поправете го.
        :cxx
            template <typename It>
            void reverse(It begin, It end)
            {
                while (begin != end && begin != --end)
                    std::swap(*begin++, *end);
            }

    li (1) От какво е съставен интерфейсът на един клас T?
        ul.choice
            li публичните методи
            li публичните член данни
            li функциите взимащи T като аргумент
            li функциите от namespace-а на T

    li (1) Какви са предимствата при използване на pImpl спрямо обикновен
        | клас?
        ul.choice
            li намалява компилацинните зависимости
            li скрива имплементационните детайли
            li по-висока производителност при извикване на методи

    li (1) Какви са предимствата при използване на pImpl спрямо абстрактен
        | клас?
        ul.choice
            li намалява компилацинните зависимости
            li скрива имплементационните детайли
            li по-висока производителност при извикване на методи

    li (3) Какви условия трябва да изпълняват библиотеката и
        | клиентското приложение, ако използват STL типове в
        | интерфейса на библиотеката?
        ul.choice
            li един и същи компилатор
            li една и съща стандартна библотека
            li една и съща runtime библиотека
            li няма условия

    li (4) Какви са недостатъците на използването на кодове за грешка?

    li (2) Какво се случва ако по време на развиване на стека се появи
        | ново изключение?
        ul.choice
            li ще започне да се обработва новото изключение
            li undefined behavior
            li ще се извика std::terminate

    li (2) Какво означава the no-throw exception safety guarantee?

    li (4) По какъв алгоритъм се избира catch клауза, която да хване
        | дадено изключение?

    li (2) Какво условие трябва да изпълнява дадена lambda функция за
        | да е съвместима с указател към обикновена фунцкия?
        ul.choice.inline
            li Да няма аргументи
            li Да има празен capture
            li Няма как lambda да е съвместима с указател към функция

    li (4) Използвайте scope_exit, така че независимо какво се случи,
        | транзакцията ще бъде или комитната или отменена

        :cxx
            // scope_exit returns an object which executes a funtion
            // when the object is destroyed, i.e. the scope exits
            template <typename Functor>
            magic scope_exit(Functor f);

            class Query {
                void execute() {
                    _success = false;
                    // ... do work
                    _success = true;
                }
                void commit_or_rollback() {
                    if (_success) {
                        commit();
                    } else {
                        rollback();
                    }
                }
                void rollback();
                void commit();
                bool _success;
            };
