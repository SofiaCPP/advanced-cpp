+++ slide

Templates and Generic Programming

+++
+++ slide

Table of Contents

+++
=== topic
+++ slide

Въведение в C++ шаблони

+++
+++ slide

The Good

Едно от най-мощните изразителни средства на C++

– Шаблоните в C++ са turing-complete (т.е. са пълен език за програмиране)
– metaprogramming - изчисления по време на компилация и “ смятане” с типове
– expression templates и други Domain Specific Languages вмъкнати в C++
– n-торки
– type traits

+++
+++ slide

The Ugly

- Една от последно вмъкнатите в C++98 възможности на
  езика
  – По-лоша поддръжка от страна на компилаторите и по-големи
    разлики между тях

    - keyword “extern”

  – Липса на ортогоналност поради технически или исторически
    причини

    - параметри по подразбиране за шаблонни функции
    - floating-point стойности за шаблонни аргументи

  – Много синтактични особености


+++
+++ slide

## Шаблонни функции

+++
+++ slide

template <"тип параметър1" "име на параметър1"{, "тип параметър2"
"име на параметър2"}>

<тип на резултата>

f(<формални аргументи на функцията>);

+++
+++ slide

Шаблонни параметри

"тип параметър" - типът на параметъра
  – typename, class - този параметър означава име на тип
    - typename и class са едно и също в този контекст, но typename е за
      предпочитане
    - тук не можете да използвате struct вместо class
  – име на тип - този параметър ще бъде стойност от посочения тип
    - тук не можете да използвате произволен тип
  – декларация на друг шаблон !

+++
+++ slide

    template <typename T>
    inline const T& max(const T& x, const T& y) {
        return (x < y)? y : x;
    }

    int main() {
        // using ::max to avoid std::max
        std::cout << ::max(24, 42) << std::endl;
        std::cout << ::max<double>(9.8, 3.14) << std::endl;
        // явно задаване на T
        std::cout <<
            ::max(std::string("path"),
                  std::string("pathology"));
        return 0;
    }

+++
+++ slide

Инстанцииране

• Шаблонната функция `max` не се компилира до една функция, която да работи с
  всички типове аргументи, а за всеки тип аргументи се създава отделна функция
  `max`.
• Това създаване се нарича инстанцииране (instantiation)
• Инстанциирането е автоматично, но може да бъде и явно.
• Ако се опитаме да инстанциираме шаблонна функция за тип аргументи, който не
  изпълнява всички изисквания на шаблона ( в случая на max - operator< ), ще се
  получи грешка при компилация

+++
+++ slide

Компилиране на шаблони

Шаблоните се компилират на два етапа:

1. Преди инстанцииране - компилатора прави само проверка на синтаксиса -
   например за липсващи ";"

2. По време на инстанцииране - компилатора компилира кода на шаблона и прави
   проверка за валидността на всички използвани функции, методи и оператори

+++
+++ slide


- За да бъде инстанцииран един шаблон, компилаторът трябва да вижда неговата
  дефиниция.
- Това налага повечето шаблони да бъдат дефинирани в header файлове, които се
  включват в ползващите шаблона файлове

+++
+++ slide

Recap

- Шаблонните функции дефинират фамилия от функции за различните шаблонни
  аргументи.
- Когато подавате шаблонни аргументи, шаблонната функция се инстанцира за тези
  типове.
- Можете явно да задавате шаблонни аргументи.

+++
+++ slide

## Шаблонни класове

+++
+++ slide

    template <"тип параметър1" "име на параметър1"{, "тип параметър2"
    "име на параметър2"}>
    [class|struct] A;

+++
+++ slide

    template <typename T>
    class Stack {
      public:
        void push(const T&);
        void pop();
        T top() const;
        bool empty() const;
      private:
        std::vector<T> _s;
    } ;

+++
+++ slide

    template <typename T>
    void Stack<T>::push(const T& x)
    {
        _s.push_back(x);
    }

+++
+++ slide

    int main() {
        Stack<int> stackInts;
        // предизвиква инстанцииране на Stack<int>, но не на всички функции
        Stack<string> stackStrings;
        // Stack<int> и Stack<string> са два напълно различни типа !

        stackInts.push(42);

        // ...
        return 0;
    }


+++
+++ slide

    void f(Stack &s);
    // грешка, Stack е име на шаблон, а не тип


    void f(Stack<int>& s);

    // ok, Stack<int> е име на тип

    template <typename T>
    void f(Stack<T>& s);

    // ok, f е шаблонна функция, Stack<T> ще бъде име на тип при инстанциирането й

+++
+++ slide

    template <typename T,
             typename Cont = std::vector<T> >

    class Stack {
      public:

        // ...

      private:
        Cont _s;
    } ;

    int main() {
        Stack<int> stackIntsVector;
        Stack<int, deque<int> > stackIntsDeque;
    }

+++
+++ slide

Инстанциране на шаблонни класове

- Шаблоните се проверяват за синтактични грешки, а останалите проверки се правят
  при инстанциирането
- Инстанциират се само методите, който се използват!

  – Някоя семантична грешка може да мине незабелязана от компилатора
  – За да се инстанциират всички методи на шаблона използвайте явно
    инстанцииране (explicit instantiation)

+++
+++ slide

    template <typename T>
    bool Stack<T>::empty() const { return _s == 0; }
    // vector<T> няма operator==(int);

    int main() {
        Stack<int> s;
        s.push(42);
        return 0;
    }

    // Не използваме никъде Stack<int>::empty!
    // Кода се компилира и изпълнява чудесно

+++
+++ slide

Бележки

- Инстанциират се само тези методи на шаблона, които се използват!
- Можете да дефинирате стойност по подразбиране за параметри на шаблона, те
  могат да използват предходните параметри.

+++
===
=== topic
+++ slide

## Не-типови шаблонни параметри

+++
+++ slide

Шаблонните параметри освен типове могат да и обикновени стойности, но от типове
отговарящи на определени условия.

+++
+++ slide

    template <typename T, unsigned Size>
    class Array {
      public:
        // ...
        T& operator[] (size_t i) { return _a[i]; }
        Т& at(size_t i) {
            if (i > Size)
                throw std::out_of_range("i tоо large");
            return _a[i];
        }
      private:
        T[Size] _a;
    } ;

+++
+++ slide


    template <typename T, T Value>
    T increase(const T& x) { return x + Value; }
    // съвсем не достатъчно generic

+++
+++ slide

    int main() {
        cout << increase<int, 10>(32) << endl;
        return 0;
    }

+++
+++ slide

Условия за не-типовите шаблонни параметри

- Могат да бъдат константни интегрални стойности (включително enum) или
  указатели към обекти с външно свързване

  – интегрална стойност - проста, неделима стойност
  – указател към обект с външно свързване - указател към глобален за цялата
    програма

- Не могат да бъдат floating-point числа и обекти от непримитивен тип

  – floating-point не се разрешава по исторически причини, в
    бъдеще може да се допусне

+++
+++ slide

    template <const char* s>
    class MyClass;

    MyClass<"Hello"> e;
    // грешка, "Hello" е string literal

    const char* s = "hello";

    MyClass<s> e2;
    // грешка, s е указател към обект с internal linkage

    extern const char[] s2 = "hello";

    MyClass<s2> o; // ok

+++
===
=== topic
+++ slide

# Шаблоните в детайли

+++
+++ slide

## Инстанцииране на шаблони

+++
+++ slide

### Компилиране на шаблони

+++
+++ slide

- Шаблоните се компилират на два етапа:

  1. Преди инстанцииране - компилатора прави само проверка на синтаксиса -
    например за липсващи ";"

  2. По време на инстанцииране - компилатора компилира кода на шаблона и прави
    проверка за валидността на всички използвани функции, методи и оператори

+++
+++ slide

- За да бъде инстанцииран един шаблон, компилаторът трябва да вижда неговата
  дефиниция.

- Това налага повечето шаблони да бъдат дефинирани в header файлове, които се
  включват в ползващите шаблона файлове

+++
+++ slide

Инстанцииране на шаблони

- Не явно - автоматично при използване на шаблонна функция или клас
- Явно (explicit instantiation)

  – предизвиква инстанциирането на всички методи на класа
  – `template int f<double, double>(double, double);`
  – `template class MyStack<int>;`

+++
+++ slide

    template <typename T> class C; // forward

    C<int>* p; // ok

    template <typename T>
    class C {
      public:
        void f(); // декларация на C::f()
    } ; // дефиниция на C

+++
+++ slide

Мързеливо инстанцииране

+++
+++ slide

Каква част от един шаблонен клас се инстанциира при неявно инстанцииране?

- Колкото се може по-малко
  – декларациите на всички членове на класа и на членовете на съдържащи се
    анонимни union
  – дефинициите на virtual член функции биха могли да бъдат или да не бъдат
    инстанциирани
    - повечето компилатори ще ги инстанциират, тъй като имплементацията им на
      virtual механизма изисква тези функции да съществуват
  – параметри по подразбиране на функции се инстанциират само ако име извикване
    на функцията, при което параметърът по подразбиране се използва

+++
===
=== topic
+++ slide

Name lookup

+++
+++ slide

Name Lookup?

  name lookup процесът, при който компилаторът свързва използваните имена с
  обектите, които те представляват

- в случая под обекти разбираме функции, оператори и типове

+++
+++ slide

Видове имена в C++

- Разпределянето на имената в C++ в класове е доста сложно
- Най-основно е следното разделяне:
  - квалифицирано и не-квалифицирано име
  - зависимо и независимо име

+++
+++ slide

Квалифицирано име е име, чийто обхват е явно указан чрез оператора `::` (scope
resolution operator) или операторите `.` и `->` (member access operators)

- this->count и count не са съвсем едно и също, но са две имена на едно и също в
  рамките на дефиниция на клас

+++
+++ slide

Зависимо име е име, което зависи по някакъв начин от шаблонен параметър

- `std::vector<T>::iterator` е зависимо име ако `T` е шаблонен параметър и е
  независимо име ако Т е име на известен тип

- `this->x` - `x` е зависимо име, когато се среща в шаблон

- `f(x)` е зависимо име, ако типът на `x` зависи от шаблонен параметър

+++
+++ slide

Правила за търсене на имена

- Правилата за търсене на име са пълни с различни детайли за да работят
  интуитивно в общия случай и коректно в сложни частни случаи.

+++
+++ slide

Основни правила

- квалифицирани имена се търсят в посоченото от квалификацията пространство от
  имена

+++
+++ slide

- неквалифицираните имена се търсят в последователно разширяващи се пространства
  от имена

  – започва се от текущото пространство, след това се търси в пространството
    съдържащо текущото и така нататък докато не се намери обект определен от
    това име

+++
+++ slide

Argument Dependent Lookup

- за неквалифицираните имена се прилага и Argument Dependent Lookup (ADL, Koenig
  Lookup)

  – когато се търси функция с определено име освен в текущото и обхващащите го
    пространства от имена се търси и в пространствата, асоциирани със типовете
    на аргументите

  – Базира се на идеята, че интефейсът на един клас е съставен от публичните му
    методи и всички функции дефинирани в същото пространство от имена, който
    приемат параметри от този клас

+++
+++ slide

    namespace Lib {
        class A { // ... } ;

        ostream& operator<<(ostream& s,const A& a);

        bool operator==(const A& l, const A& r);
    }

    int main() {
        cout << a2 == a1 << endl;
        return 0;
    }

+++
+++ slide

Асоциирани пространства от имена - 1

- за примитивните типове - празното множество
- за указатели и масиви - пространството асоциирано със съответния тип на
  сочения / съдържания обект
- за enum - пространството, в което е дефиниран enum-ът
- за членове на клас - пространството е самият клас

+++
+++ slide

Асоциирани пространства от имена - 2

- за класове - множеството от асоциирани класове е самият клас, съдържащият го
  клас и всеки пряк или непряк родителски клас.  Асоциираното пространство от
  имена са пространствата от имена, в които са декларирание асоциираните класове

  – при инстанцииране на шаблон, класовете на типовите шаблонни параметри и
    класовете и пространствата, в които са декларирани шаблонните шаблонни
    аргументи също се включват

+++
+++ slide

Асоциирани пространства от имена - 2

- за указател към член на клас X - освен асоциираните с X пространства се
  включват и пространствата асоциирани с типа на сочения член

  – за указатели към методи - типа на резултата и типовете на параметрите също
    допринасят с техните асоциирани пространства от имена

+++
+++ slide

ADL

- ADL търси името във всяко от асоциираните пространства все едно името е било
  квалифицирано в това пространство, като игнорира `using` директивите

+++
+++ slide

    namespace X {
        template <typename T> void f(T);
    }

    namespace N {
        using namespace X;

        enum E { e1 } ;
        void f(E) { cout << "N::f(E)\n"; }

    }

    void f(int) { cout << "::f()\n"; }

    void g() {
        ::f(N::e1); // квалифицирано, без ADL
        f(N::e1); // неквалифицирано, ADL
        // X::f() изобщо не се разглежда
    }

+++
===
=== topic
+++ slide

Two-Phase Lookup

+++
+++ slide

- При първоначалното компилиране на шаблона, зависимите имена не могат да бъдат
  свързани с функции и типове.
- Затова се въвежда two-phase lookup

  1. Независимите имена се свързват със съответните функции и типове по време на
     компилация на шаблона

  2. Зависимите имена се свързват в момента на инстанцииране

  Point of Instantiation (POI) точката на инстанцииране на шаблона - на това
  място компилаторът слага дефиницията на инстанциирания шаблон

+++
+++ slide

    template <typaname T>
    void f(T x) {
        if (x > 0)
            g(x);
    }

    // (1)

    namespace Lib {
        // (2)
        void g(MyInt y) {
            // (3)
            f<MyInt>(42); // точка на извикване
            // (4)
        }
        // (5)
    }
    // (6)

+++
+++ slide

Точка на инстанцииране

- Точката на инстанцииране не може да съвпадне с точката на извикване, защото не
  можете да дефинирате функция в друга функция

  – съответно отпадат точки (3) и (4)

- в точки (1) и (2) g(MyInt x) не е видима, което не е особено интуитивно

- в точка (5) и (6) g(MyInt x) е видима

- Точката на инстанцииране на шаблонни функции е веднага след най-близката
  декларация или дефиниция която съдържа обръщение към шаблона (в подходящия
  namespace) - (6) в нашия пример

+++
+++ slide

    template <typaname T>
    void f(T x) {
        if (x > 0)
            g(x);
    }

    namespace Lib {
        void g(int y) {
            // (2)
            f<int>(42);
            // (3)
        }
    }

+++
+++ slide

Предишният пример не се компилира, защото:

- template void f(T) е глобален шаблон и инстнацията на шаблона съответно е в
  глобалния namespace
- няма глобална функция g
- ADL не може да намери g, понеже int е примитивен тип

+++
===
=== topic
+++ slide

# Специализация на шаблони

+++
===
=== topic
+++ slide

# Tricky details

+++
+++ slide

## Ключова дума typename

+++
+++ slide

    template <typename T>
    class MyClass {
        typename T::SubType * ptr; // static member
        // T::StaticMember * ptr; // multiplication
    };

+++
+++ slide

- Квалифицирано име не се смята за тип, освен ако не е предшествано от `typename`.
- `typename` е задължително да се използва пред едно име, ако:
  1. името е в шаблон
  2. името е квалифицирано
  3. името не е в списък на базовите класове или в списък за инициализация на
     базовите класове
  4. името зависи от параметър на шаблона
- Ако едно от първите 3 не е изпълнено е грешка да се използва `typename`

+++
+++ slide

    template <typename_1 T>
    struct S: typename_2 X<T>::Base {
        S(): typename_3 X<T>::Base(typename_4 X<T>::Base(0))
        { }
        typename_5 X<T> f() {
            typename_6 X<T>::C * p;
            X<T>::D * q;
        }
        typename_7 X<int>::C * s;
    };
    struct U {
        typename_8 X<int>::C * pc;
    };

+++
+++ slide

1. декларация на параметър на шаблона
2. грешно - списък на базовите класове
3. грешно - инициализиращ списък
4. необходимо - създаване на обект от `X<T>::Base`
5. грешно - `X<T>` не е квалифицирано име
6. задължително, ако декларираме указател
7. опционално - `s` е независимо име
8. грешка - извън шаблона

+++
+++ slide

## Ключова дума template

+++
+++ slide

    template <int N>
    void printBitset(const std::bitset<N>& bs) {
        typedef char_traits<char> traits;
        typedef allocator<char> char_alloc;
        cout << bs.template to_string<char, traits, char_alloc>();
    }

+++
+++ slide

`bs` е зависимо име и компилаторът не знае дали `<` между `to_string` и `char` е
`operator<` или скоба за шаблонни аргументи.

+++
+++ slide

Може да се ползва и с указатели:

    p->template to_string< ... >()

+++
+++ slide

## Синтактични проблеми

+++
+++ slide

    typedef vector<vector<int> > Matrix;
    // C++ 98 - >> is operator >>
    // lexer tokens are the longest possible

    // C++ 11
    typedef vector<vector<int>> Matrix;

+++
+++ slide

class A;
namespace L {
    typedef std::vector<::A> VectorA;
    // <: is a digraph and actually means [
}

namespace L {
    typedef std::vector< ::A> VectorA;
}

+++
===
