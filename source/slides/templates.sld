+++ slide

Templates and Generic Programming

+++
+++ slide

Table of Contents

+++
=== topic
+++ slide

Въведение в C++ шаблони

+++
+++ slide

The Ugly

- Една от последно вмъкнатите в C++98 възможности на 
  езика
  – По-лоша поддръжка от страна на компилаторите и по-големи 
    разлики между тях

    - keyword “extern”

  – Липса на ортогоналност поради технически или исторически 
    причини

    - параметри по подразбиране за шаблонни функции
    - floating-point стойности за шаблонни аргументи

  – Много синтактични особености

+++
+++ slide

The Good

Едно от най-мощните изразителни средства на C++

– Шаблоните в C++ са turing-complete (т.е. са пълен език за програмиране)
– metaprogramming - изчисления по време на компилация и “ смятане” с типове
– expression templates и други Domain Specific Languages вмъкнати в C++
– n-торки
– type traits

+++
+++ slide

## Шаблонни функции

+++
+++ slide

template <"тип параметър1" "име на параметър1"{, "тип параметър2" 
"име на параметър2"}>

<тип на резултата>

f(<формални аргументи на функцията>);

+++
+++ slide

Шаблонни параметри

“тип параметър” - типът на параметъра
  – typename, class - този параметър означава име на тип 
    - typename и class са едно и също в този контекст, но typename е за
      предпочитане
    - тук не можете да използвате struct вместо class
  – име на тип - този параметър ще бъде стойност от посочения тип
    - тук не можете да използвате произволен тип
  – декларация на друг шаблон !

+++
+++ slide

    template <typename T>
    inline const T& max(const T& x, const T& y) {
        return (x < y)? y : x;
    }

    int main() {
        // using ::max to avoid std::max
        std::cout << ::max(24, 42) << std::endl;
        std::cout << ::max<double>(9.8, 3.14) << std::endl;
        // явно задаване на T
        std::cout <<
            ::max(std::string("path"),
                  std::string("pathology"));
        return 0;
    }

+++
+++ slide

Инстанцииране

• Шаблонната функция `max` не се компилира до една функция, която да работи с
  всички типове аргументи, а за всеки тип аргументи се създава отделна функция
  `max`.
• Това създаване се нарича инстанцииране (instantiation)
• Инстанциирането е автоматично, но може да бъде и явно.
• Ако се опитаме да инстанциираме шаблонна функция за тип аргументи, който не
  изпълнява всички изисквания на шаблона ( в случая на max - operator< ), ще се
  получи грешка при компилация

+++
+++ slide

Компилиране на шаблони

Шаблоните се компилират на два етапа:

1. Преди инстанцииране - компилатора прави само проверка на синтаксиса -
   например за липсващи “;”

2. По време на инстанцииране - компилатора компилира кода на шаблона и прави
   проверка за валидността на всички използвани функции, методи и оператори

+++
+++ slide


• За да бъде инстанцииран един шаблон, компилаторът трябва да 
  вижда неговата дефиниция.

• Това налага повечето шаблони да бъдат дефинирани в header 
  файлове, които се включват в ползващите шаблона файлове

+++
+++ slide

Recap

• Шаблонните функции дефинират фамилия от функции за различните 
  шаблонни аргументи.

• Когато подавате шаблонни аргументи, шаблонната функция се 
  инстанцира за тези типове.

• Можете явно да задавате шаблонни аргументи.

+++
+++ slide

## Шаблонни класове

+++
+++ slide

template <"тип параметър1" "име на параметър1"{, "тип параметър2" 
"име на параметър2"}>
[class|struct] A;

template <typename T>
class Stack {
  public:
    void push(const T&);
    void pop();
    T top() const;
    bool empty() const;
  private:
    std::vector<T> _s;
} ;

template <typename T>
void Stack<T>::push(const T& x) { _s.push_back(x); }

int main() {
    Stack<int> stackInts;
    // предизвиква инстанцииране на Stack<int>, но не на всички функции
    Stack<string> stackStrings;
    // Stack<int> и Stack<string> са два напълно различни типа !

    stackInts.push(42);

    // ...
    return 0;
}

void f(Stack &s);
// грешка, Stack е име на шаблон, а не тип


void f(Stack<int>& s);

// ok, Stack<int> е име на тип

template <typename T>
void f(Stack<T>& s);

// ok, f е шаблонна функция, Stack<T> ще бъде име на тип при инстанциирането й

template <typename T,
         typename Cont = std::vector<T> >

class Stack {
  public:

    // ...

  private:
    Cont _s;
} ;

int main() {
    Stack<int> stackIntsVector;
    Stack<int, deque<int> > stackIntsDeque;
}

Инстанциране на шаблонни класове

• Шаблоните се проверяват за синтактични грешки, а останалите проверки се правят
  при инстанциирането

• Инстанциират се само методите, който се използват!

  – Някоя семантична грешка може да мине незабелязана от компилатора
  – За да се инстанциират всички методи на шаблона използвайте явно
    инстанцииране (explicit instantiation)

template <typename T>
bool Stack<T>::empty() const { return _s == 0; }
// vector<T> няма operator==(int);

int main() {
    Stack<int> s;
    s.push(42);
    return 0;
}

// Не използваме никъде Stack<int>::empty!
// Кода се компилира и изпълнява чудесно

Бележки

• Инстанциират се само тези методи на шаблона, които се използват!

• Можете да дефинирате стойност по подразбиране за параметри на 
  шаблона, те могат да използват предходните параметри.

Subsection 1.3 Не-типови шаблонни параметри

Не-типови шаблонни параметри

• Шаблонните параметри освен типове могат да и обикновени 
  стойности, но от типове отговарящи на определени условия

template <typename T, unsigned Size>

class Array {

  public:

    // ...

    T& operator[] (size_t i) { return _a[i]; }

    Т& at(size_t i) {

        if (i > Size)

            throw std::out_of_range("i tоо large");

        return _a[i];

    }

  private:

    T[Size] _a;

} ;

template <typename T, T Value>

T increase(const T& x) { return x + Value; }

// съвсем не достатъчно generic



int main() {

    cout << increase<int, 10>(32) << endl;

    return 0;

}

Условия за не-типовите шаблонни параметри

• Могат да бъдат константни интегрални стойности (включително 
  enum) или указатели към обекти с външно свързване

  – интегрална стойност - проста, неделима стойност

  – указател към обект с външно свързване - указател към глобален 
    за цялата програма

• Не могат да бъдат floating-point числа и обекти от непримитивен 
  тип

  – floating-point не се разрешава по исторически причини, в 
    бъдеще може да се допусне

  – Вече трябва да е ясно защо increase не е достатъчно generic

template <const char* s>

class MyClass;



MyClass<"Hello"> e;

// грешка, "Hello" е string literal



const char* s = "hello";

MyClass<s> e2;

// грешка, s е указател към обект с internal linkage



extern const char[] s2 = "hello";

MyClass<s2> o; // ok

Section 2 Шаблоните в детайли

Subsection 2.1 Инстанцииране на шаблони

Компилиране на шаблони

• Шаблоните се компилират на два етапа:

  1. Преди инстанцииране - компилатора прави само проверка на 
    синтаксиса - например за липсващи “;”

  2. По време на инстанцииране - компилатора компилира кода на 
    шаблона и прави проверка за валидността на всички използвани 
    функции, методи и оператори



• За да бъде инстанцииран един шаблон, компилаторът трябва да 
  вижда неговата дефиниция.

• Това налага повечето шаблони да бъдат дефинирани в header 
  файлове, които се включват в ползващите шаблона файлове

Инстанцииране на шаблони

• Не явно - автоматично при използване на шаблонна функция или 
  клас

• Явно (explicit instantiation)

  – предизвиква инстанциирането на всички методи на класа

  – template int f<double, double>(double, double);

  – template class MyStack<int>;

template <typename T> class C; // forward

C<int>* p; // ok

template <typename T>

class C {

  public:

    void f(); // декларация на C::f()

} ; // дефиниция на C



void g(C<int>& c)

{ c.f(); } // използва дефиницията на C

// необходима е дефиниция на C::f()

template <typename T>

class C {

  public:

    C(int); // може да се ползва за конвертирания

} ;

void f(C<double> &);

void f(int);



void g() { f(42); }

// компилаторът може да инстанциира C<double>

// за да провери дали коя f да извика

Мързеливо инстанцииране

Каква част от един шаблонен клас се инстанциира при неявно 
инстанцииране?



• Колкото се може по-малко

  – декларациите на всички членове на класа и на членовете на 
    съдържащи се анонимни union

  – дефинициите на virtual член функции биха могли да бъдат или 
    да не бъдат инстанциирани

    ∗ повечето компилатори ще ги инстанциират, тъй като 
      имплементацията им на virtual механизма изисква тези 
      функции да съществуват

  – параметри по подразбиране на функции се инстанциират само ако 
    име извикване на функцията, при което параметърът по 
    подразбиране се използва

Subsection 2.2 Name lookup

Name Lookup?

  name lookup процесът, при който компилаторът свързва 
  използваните имена с обектите, които те представляват

• в случая под обекти разбираме функции, оператори и типове

Видове имена в C++

• Разпределянето на имената в C++ в класове е доста сложно

• Най-основно (и сравнително достатъчно за нашите цели тук) е 
  следното разделяне

  – квалифицирано име е име, чийто обхват е явно указан чрез 
    оператора :: (scope resolution operator) или операторите . и 
    -> (member access operators)

    ∗ this->count и count не са съвсем едно и също, но са две 
      имена на едно и също в рамките на дефиниция на клас

  – зависимо име е име, което зависи по някакъв начин от шаблонен 
    параметър

    ∗ std::vector<T>::iterator е зависимо име ако T е шаблонен 
      параметър и е независимо име ако Т е име на известен тип

    ∗ this->x - x е зависимо име, когато се среща в шаблон

    ∗ f(x) е зависимо име, ако типът на x зависи от шаблонен 
      параметър

Правила за търсене на имена

• Правилата за търсене на име са пълни с различни детайли за да 
  работят интуитивно в общия случай и коректно в сложни частни 
  случаи.

Основни правила

• квалифицирани имена се търсят в посоченото от квалификацията 
  пространство от имена

• неквалифицираните имена се търсят в последователно разширяващи 
  се пространства от имена

  – започва се от текущото пространство, след това се търси в 
    пространството съдържащо текущото и така нататък докато не се 
    намери обект определен от това име

Argument Dependent Lookup

• за неквалифицираните имена се прилага и Argument Dependent 
  Lookup (ADL, Koenig Lookup)

  – когато се търси функция с определено име освен в текущото и 
    обхващащите го пространства от имена се търси и в 
    пространствата, асоциирани със типовете на аргументите

  – Базира се на идеята, че интефейсът на един клас е съставен от 
    публичните му методи и всички функции дефинирани в същото 
    пространство от имена, който приемат параметри от този клас

namespace Lib {

    class A { // ... } ;

    ostream& operator<<(ostream& s,const A& a);

    bool operator==(const A& l, const A& r);

}



int main() {

	Lib::A a1, a2;

    cout << a1 << " " << endl;

    cout << a2 == a1 << endl;

    return 0;

}

Асоциирани пространства от имена - 1

• за примитивните типове - празното множество

• за указатели и масиви - пространството асоциирано със 
  съответния тип на сочения / съдържания обект

• за enum - пространството, в което е дефиниран enum-ът

• за членове на клас - пространството е самият клас

Асоциирани пространства от имена - 2

• за класове - множеството от асоциирани класове е самият клас, 
  съдържащият го клас и всеки пряк или непряк родителски клас. 
  Асоциираното пространство от имена са пространствата от имена, 
  в които са декларирание асоциираните класове

  – при инстанцииране на шаблон, класовете на типовите шаблонни 
    параметри и класовете и пространствата, в които са 
    декларирани шаблонните шаблонни аргументи също се включват

• за указател към член на клас X - освен асоциираните с X 
  пространства се включват и пространствата асоциирани с типа на 
  сочения член

  – за указатели към методи - типа на резултата и типовете на 
    параметрите също допринасят с техните асоциирани пространства 
    от имена

ADL

• ADL търси името във всяко от асоциираните пространства все едно 
  името е било квалифицирано в това пространство, като игнорира 
  using директивите

namespace X {

    template <typename T> void f(T);

}

namespace N {

    using namespace X;

    enum E { e1 } ;

    void f(E) { cout << "N::f(E)\n"; }

}

void f(int) { cout << "::f()\n"; }

void g() {

    ::f(N::e1); // квалифицирано, без ADL

    f(N::e1); // неквалифицирано, ADL

    // X::f() изобщо не се разглежда

}

Two-Phase Lookup

• При първоначалното компилиране на шаблона, зависимите имена не 
  могат да бъдат свързани с функции и типове.

• Затова се въвежда two-phase lookup

  1. Независимите имена се свързват със съответните функции и 
    типове по време на компилация на шаблона

  2. Зависимите имена се свързват в момента на инстанцииране

  Point of Instantiation (POI) точката на инстанцииране на 
  шаблона - на това място компилаторът слага дефиницията на 
  инстанциирания шаблон

template <typaname T>

void f(T x) {

    if (x > 0)

        g(x);

}

// (1)

namespace Lib {

    // (2)

    void g(MyInt y) {

        // (3)

        f<MyInt>(42); // точка на извикване

        // (4)

    }

    // (5)

}

// (6)

Точка на инстанцииране

• Точката на инстанцииране не може да съвпадне с точката на 
  извикване, защото не можете да дефинирате функция в друга 
  функция

  – съответно отпадат точки (3) и (4)

• в точки (1) и (2) g(MyInt x) не е видима, което не е особено 
  интуитивно

• в точка (5) и (6) g(MyInt x) е видима

• Точката на инстанцииране на шаблонни функции е веднага след 
  най-близката декларация или дефиниция която съдържа обръщение 
  към шаблона (в подходящия namespace) - (6) в нашия пример

template <typaname T>

void f(T x) {

    if (x > 0)

        g(x);

}



namespace Lib {

    void g(int y) {

        // (2)

        f<int>(42);

        // (3)

    }

}

Отговор

Предишният пример не се компилира, защото:

• template void f(T) е глобален шаблон и инстнацията на шаблона 
  съответно е в глобалния namespace

• няма глобална функция g

• ADL не може да намери g, понеже int е примитивен тип

Subsection 2.3 Специализация на шаблони

Section 3 Tricky details

Subsection 3.1 Ключова дума typename

Subsection 3.2 Ключова дума template

Subsection 3.3 Синтактични проблеми



