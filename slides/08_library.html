<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content="A course about C++"><meta name="author" content="SofiaCPP"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="stylesheet" href="/advanced-cpp/bower_components/reveal.js/css/reveal.min.css"/><link rel="stylesheet" href="/advanced-cpp/css/advanced_cxx.css"><link rel="stylesheet" href="/advanced-cpp/css/tomorrow.css"><title>Library API</title></head><body><div class="reveal"><div class="slides"><section><h1>Library API Design</h1></section><section><h2>What is an API</h2><p>Application Program Interface</p><p>The set of functions and types that a library provides</p></section><section><h2>Contents</h2><ul><li>Kind of libraries<ul><li>Header only</li><li>Static</li><li>Dynamic/shared</li></ul></li><li>Symbol linkage</li><li>interfaces</li><li>Heap allocated objects</li><li>std:: cross library</li></ul></section><section></section><section><h2>Header only libraries</h2><p>A collection of header files</p></section><section><h3 id="Pros-1">Pros</h3>
<ul>
<li>Very easy to use - just copy the files and <code>#include</code></li>
<li>No overhead at all - even some calls  might get inlined</li>
</ul>
</section><section><h3>Cons</h3><ul><li>No isolation at all - the client sees all implementation details</li><li>Changes in the library requires recompile</li><li>Difficult to use with non-open-source licenses</li><li>May significantly increase compilation time</li><li>Tends to creep all over the place</li></ul></section><section></section><section><h2>Static Libraries</h2><p>An archive of object files</p></section><section><h3>Pros</h3><ul><li>Relatively easy to use - include and link</li><li>No overhead, some calls might be inlined if we are using optimizing
linker</li></ul></section><section><h3>Cons</h3><ul><li>The compiler options must match perfectly between the library and the
clients
</li><li>Changing the library requires recompilation of the client code</li><li>3rd party dependencies conflict</li></ul></section><section></section><section><h2>Dynamic/Shared Libraries</h2><p>a single object file, that allows calling of predefined set of
functions</p></section><section><h3>Pros</h3><ul><li>Almost complete isolation between library and client</li><li>Changing the library without recompilation can be achieved</li></ul></section><section><h3>Cons</h3><ul><li>Non standard</li><li>A lot of platform specifics</li><li>DLL boundary</li></ul></section><section></section><section><h3>Symbol Visibility</h3><ul><li>Windows - hidden by default</li><li>Others - visible by default</li></ul></section><section><h4>Symbol Visibility</h4><ul><li class="fragment fade-in">Windows<pre class="mstretch"><code>__declspec(dllimport)</code></pre><pre class="mstretch"><code>__declspec(dllexport)
</code></pre></li><li class="fragment fade-in">g++ / clang++<code><pre>// compile with flags
-fvisibility=hidden -fvisibility-inlines-hidden</pre></code><pre class="mstretch"><code>__attribute__ ((visibility (&quot;default&quot;)))
</code></pre></li></ul></section><section><h4 id="dllimport_\_dllexport"><code>dllimport</code> \ <code>dllexport</code></h4>
<pre class="mstretch"><code>__declspec(dllexport) int answer = 42;

__declspec(dllexport) int get_answer() {
  return 42;
}
</code></pre></section><section><h4 id="dllimport_\_dllexport-1"><code>dllimport</code> \ <code>dllexport</code></h4>
<pre class="mstretch"><code>class __declspec(dllexport) Renderer {
  public:
    void render(const Texture&amp; texture);
};

class Texture {
  public:
    __declspec(dllexport) void fill(Color color);
    
    void fill(byte r, byte g, byte b); // not exported
};
</code></pre></section><section><h4 id="dllexport"><code>dllexport</code></h4>
<p>Makes symbols to be exported from the DLL - visible to clients</p>
</section><section><h4 id="dllimport"><code>dllimport</code></h4>
<p>Makes symbols to be imported from a DLL, the linker is going to look
for these symbols in all linked DLLs</p>
</section><section><h4 id="dllimport_\_dllexport-1"><code>dllimport</code> \ <code>dllexport</code></h4>
<p>So the library needs to say <code>dllexport</code> and the client needs to
see <code>dllimport</code> for the same symbol</p>
</section><section><h3 id="MY_LIBRARY_API"><code>MY_LIBRARY_API</code></h3>
<pre class="mstretch"><code>#if defined(MY_LIBRARY_IMPL)
  #define MY_LIBRARY_API __declspec(dllexport)
#else
  #define MY_LIBRARY_API __declspec(dllimport)
#endif

MY_LIBRARY_API int answer();
</code></pre><p class="fragment fade-in"></p><p>Compile the library with <code>MY_LIBRARY_IMPL</code> defined</p>
<p></p></section><section><h3 id="MY_LIBRARY_API-1"><code>MY_LIBRARY_API</code></h3>
<pre class="mstretch"><code>#if defined(_WIN32)
  #define MY_LIBRARY_EXPORT __declspec(dllexport)
  #define MY_LIBRARY_IMPORT __declspec(dllimport)
#else
  #define MY_LIBRARY_EXPORT __attribute__ ((visibility (&quot;default&quot;)))
  #define MY_LIBRARY_IMPORT
#endif

#if defined(MY_LIBRARY_IMPL)
  #define MY_LIBRARY_API MY_LIBRARY_EXPORT
#else
  #define MY_LIBRARY_API MY_LIBRARY_IMPORT
#endif
</code></pre></section><section><h3>Non-Windows & 3rd party dependencies</h3><p>Controlling visibility of symbols - lack of internal linkage</p></section><section><h3>Symbol Maps</h3><code><pre>VERSION
{
        global:
                extern "C++" {
                        library*;
                };
        local: *;
};</pre></code><p>Link with:<code><pre>-Wl,--version-script=library.map
</pre></code></p></section><section><h2>Lifetime of an application</h2><div class="fragment fade-in"><build></build><ol><li>preprocess</li><li>compile time</li><li>link time</li></ol></div><div class="fragment fade-in"><execute></execute><ol start="4"><li>load time</li><li>run time</li></ol></div></section><section><h3>Linux</h3><p>Symbol resolution is done at load time, not at link time</p></section><section><ul><li>undefined symbols in the library are reported when linking an
executable, not the library itself
</li><li>Symbols in the executable or a 3rd party library can override your</li><own>symbols</own></ul><code class="fragment fade-in"><pre># link with
g++ *.o -Xlinker -Bsymbolic -o myLibrary.so
</pre></code></section><section></section><section><h2>API</h2></section><section><ol>
<li>Pure <code>C</code> </li>
<li><code>C++</code> with <code>std::</code></li>
</ol>
</section><section><h3 id="Pure_C_API">Pure <code>C</code> API</h3>
<p>Pros</p>
<ul>
<li>the most portable - <code>C</code> has no mangling</li>
<li>easy to use with other languages<ul>
<li>luajit&#39;s libffi (Foreign Function interface)</li>
<li>Python - ctype, cffi</li>
<li>C# (.NET) - PInvoke</li>
</ul>
</li>
</ul>
<p>Cons</p>
<ul>
<li><code>C</code> - no <code>++</code> features - resource management, OOP, generics </li>
<li>prefix on every function</li>
</ul>
</section><section><h3 id="Opaque_Structure"><em>Opaque Structure</em></h3>
<pre class="mstretch"><code>// just a forward declaration
typedef struct lua_State lua_State;
lua_State* lua_newstate();
void lua_call(lua_State* state, int arguments, int results);
void lua_close(lua_State*);
</code></pre></section><section><h3 id="C++_with_C_API"><code>C++</code> with <code>C</code> API</h3>
<pre class="mstretch"><code>typedef struct lua_State lua_State;
extern &quot;C&quot; lua_State* lua_newstate();
extern &quot;C&quot; {
  int lua_compile(lua_State* state, const char* file);
  int lua_run(lua_State* state, int);
}</code></pre><pre class="mstretch"><code>struct lua_State {
  bool compile(const char* file);
} ;

lua_State* lua_newstate() {
  return new lua_State;
}

int lua_compile(lua_State* state, const char* file) {
  return state-&gt;compile(file)? 1 : 0;
}
</code></pre></section><section><h3 id="Having_std::_in_the_API">Having <code>std::</code> in the API</h3>
<ul>
<li>Works only for <em>header-only</em> libraries or libraries that are
compiled by the user</li>
<li>Or there must be a separate compiliant for each possible
compiler / runtime / flags combination</li>
</ul>
</section><section><h3 id="std::"><code>std::</code></h3>
<p>The standard doesn&#39;t define implementation details for the standard
library. So implementations may differ. For example:</p>
</section><section><pre class="mstretch"><code>// GCC
class pseudo_vector {
  T* begin;
  T* end;
  T* end_of_storage;
};

// MSVS
class pseudo_vector {
  T* begin;
  T* end_of_storage;
  T* end;
};
</code></pre></section><section><pre class="mstretch"><code>namespace library {
  void add_random(std::vector&lt;int&gt;&amp; numbers) {
    numbers.push_back(rand());
  }
}
</code></pre></section><section><p>Implementation may be different when using different compiler options</p>
<p>Visual Studio has <em>debug iterators</em> enabled in <em>Debug</em> build. They
allow to detect incorrect usage of <code>STL</code>. For example, using an
iterator to a vector, after it has been invalidated.</p>
<p>In <em>Release</em> a <code>vector::iterator</code> can be a plain pointer, but a
<em>debug iterator</em> is actually a smart pointer</p>
</section><section><h3 id="Memory_allocation">Memory allocation</h3>
<p>Allocated memory must be freed from the allocator that allocated it.</p>
<ul>
<li>the library and the client <em>MUST</em> use the same allocator</li>
<li>the deallocation <em>MUST</em> happen in the same module as the
corresponding allocation</li>
</ul>
</section><section><p><code>STL</code> hides allocations from the user, so it impossible to be sure
that the memory will be deallocated from the allocator that allocated
it.</p>
</section><section><h2 id="C_with_classes_/_COM"><em><code>C</code> with classes</em> / <em>COM</em></h2>
<ul>
<li>a <code>extern &quot;C&quot;</code> function that initializes the library and returns
an object that implements the library interface</li>
<li>functions and methods take only primitive types and pointers to
interfaces</li>
</ul>
</section><section><h4 id="Lua_C_with_classes_style_-_declaration">Lua <em><code>C</code> with classes</em> style - declaration</h4>
<pre class="mstretch"><code>namespace Lua {
  class State {
    virtual void ~Lua() = 0;
    virtual void destroy() = 0;
    virtual bool compile(const char* file) = 0;
  };
}
extern Lua::State* lua_new_state();
</code></pre></section><section><h4 id="Lua_C_with_classes_style_-_implementation">Lua <em><code>C</code> with classes</em> style - implementation</h4>
<pre class="mstretch"><code>namespace Lua {

  class StateImpl: public State {
  
    virtual void ~State() {
    }
    
    virtual void destroy() override {
      delete this;
    }
    
    virtual bool compile(const char* file) override {
      /...
    }
  };
}
</code></pre></section><section><h4 id="Lua_C_with_classes_style_-_implementation-1">Lua <em><code>C</code> with classes</em> style - implementation</h4>
<pre class="mstretch"><code>Lua::State* lua_newstate() {
  return new StateImpl;
}
namespace Lua {
  void StateImpl::destroy() override {
    delete this;
  }
}</code></pre><p>Enforces that the <code>StateImpl</code> object is deallocated using the
allocator that allocated it</p>
</section><section><h4 id="Lua_C_with_classes_style_-_client">Lua <em><code>C</code> with classes</em> style - client</h4>
<pre class="mstretch"><code>auto lua = lua_new_state();
lua-&gt;compile(&quot;hello.lua&quot;);
lua-&gt;destroy();
</code></pre></section><section><h4 id="Lua_C_with_classes_style_-_resources">Lua <em><code>C</code> with classes</em> style - resources</h4>
<pre class="mstretch"><code>struct LuaDestroyer {
  void operator(Lua::State* lua) {
    lua-&gt;destroy();
  }
};

std::unique_ptr&lt;Lua::State, LuaDestroyer&gt; lua(lua_new_state());
lua-&gt;compile(&quot;hello.lua&quot;);

</code></pre></section><section><h3 id="Why_not_exporting_the_StateImpl_class_directly?">Why not exporting the StateImpl class directly?</h3>
<ul class="fragment fade-in"><li>Have to export all of its base classes and member types</li><li>Exposes the implementation to the client. Client needs to be
recompiled if the implementation changes</li><li>Will work only with one compiler because of the different name
mangling schemes</li></ul></section><section><h3 id="Why_exporting_an_abstract_class_works">Why exporting an <em>abstract class</em> works</h3>
<p>An abstract class is just a virtual table - it matches the <em>COM</em>
model, and all compilers implement it in the same way.</p>
</section><section><h2 id="Resources">Resources</h2>
<p>[HowTo: Export C++ classes from a DLL]
(<a href="http://www.codeproject.com/Articles/28969/HowTo-Export-C-classes-from-a-DLL" target="_blank" rel="external">http://www.codeproject.com/Articles/28969/HowTo-Export-C-classes-from-a-DLL</a>)</p>
</section><section></section><section><h2 id="pImpl">pImpl</h2>
<p><em>Pointer-to-Implementation</em> is a technique for reducing coupling
between a class (a library) and its clients</p>
</section><section><h3 id="Pros-2">Pros</h3>
<ul>
<li>Allows the class implementation to change with recompiling the
client</li>
<li>Reducing compilation times by including <em>expensive</em> headers only in
a single source file</li>
</ul>
</section><section><h3 id="Cons-1">Cons</h3>
<ul>
<li>Prevents function inlining </li>
<li>Adds an extra redirection for each call</li>
</ul>
</section><section><h3 id="Resources-1">Resources</h3>
<ul>
<li>(A Twist on pImpl)[<a href="http://coherent-labs.com/a-twist-on-pimpl/" target="_blank" rel="external">http://coherent-labs.com/a-twist-on-pimpl/</a>]</li>
<li>(A Twist on pImpl Gist)[<a href="https://gist.github.com/dimitarcl/3771331/" target="_blank" rel="external">https://gist.github.com/dimitarcl/3771331/</a>]</li>
</ul>
</section><section><h3 id="Usage_of_pImpl">Usage of pImpl</h3>
<p>Almost every project is divided in sub-projects according to some
principles. For example:</p>
<ul>
<li>Implementation: separating platform specific code</li>
<li>Aspect: logging, profiling</li>
<li>Functionality: Rendering</li>
</ul>
</section><section><h3 id="Usage_of_pImpl-1">Usage of pImpl</h3>
<p><em>pImpl</em> can be used to implement the interfaces of the internal
libraries in a project</p>
</section></div></div><script src="/advanced-cpp/bower_components/reveal.js/lib/js/head.min.js"></script><script src="/advanced-cpp/bower_components/reveal.js/js/reveal.min.js"></script><script src="/advanced-cpp/bower_components/reveal.js/plugin/highlight/highlight.js"></script><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/slides.js"></script></body></html>