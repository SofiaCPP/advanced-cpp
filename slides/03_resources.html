<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content="A course about C++"><meta name="author" content="SofiaCPP"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="stylesheet" href="/advanced-cpp/bower_components/reveal.js/css/reveal.min.css"/><link rel="stylesheet" href="/advanced-cpp/css/advanced_cxx.css"><link rel="stylesheet" href="/advanced-cpp/css/tomorrow.css"><title>Resource Management</title></head><body><div class="reveal"><div class="slides"><section><h1>Resource Management in C++</h1></section><section><section><h2>Resources</h2></section><section><h3>Resources are finite</h3></section><section><h3>What is a resource?</h3><ul><li>Memory</li><li>Files</li><li>Sockets</li><li>Threads</li><li>...</li></ul><aside class="notes">Memory is the most often used and miss-used resource in a computer.
GC languages focus on taking memory management out of the hands of
the programmer. But they leave everything else, and, IMHO, they make
it harder. Open files in a process or OS are limited. Sockets can't
be more than 65536 for a given IP address.
</aside></section><section><h3 id="Garbage_collection">Garbage collection</h3>
<p>Garbage collection works only for memory. It does <strong>not</strong> work for
other resources because it is generally not deterministic.</p>
</section><section><p>All GC languages have (some got at a later point) language
constructs to allow deterministic resource management.</p>
</section><section><h4>Python</h4><pre class="mstretch"><code>with open('file.txt') as file:
    for line in file:
        pass
        </code></pre></section><section><h4>C#</h4><pre class="mstretch"><code>// `IDisposable` interface

using (Font font1 = new Font(&quot;Arial&quot;, 10.0f))
{
    byte charset = font1.GdiCharSet;
}
</code></pre></section><section><h4>Go</h4><pre class="mstretch"><code>func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return &quot;&quot;, err
    }
    defer f.Close()  // f.Close will run when we're finished.
    
    </code></pre></section></section><section><h2>Lifetime of an object</h2><ul><li class="fragment fade-in">starts with completion of the constructor</li><li class="fragment fade-in">ends with the completion of the destructor</li></ul></section><section><h2>Automatic variables</h2><p class="fragment fade-in">Automatic variable is allocated and deallocated when the
program flow enters and leaves the variable's context.
</p><p class="fragment fade-in">Variable's context is the scope of its declaration</p></section><section><section><h2>Scope of a variable</h2></section><section><pre class="mstretch"><code>void function() {
    std::ifstream f(&quot;input.txt&quot;);
} // f is destroyed here
</code></pre></section><section><pre class="mstretch"><code>void function() {
    // ...
    {
        std::ifstream f(&quot;input.txt&quot;);
    } // f is destroyed here
    // ...
}
</code></pre></section><section><div data-file="03_resources/input.cxx" class="snippet"><p>// loading ...</p>
</div></section><section><div data-file="03_resources/inputstl.cxx" class="snippet"><p>// loading ...</p>
</div></section><section><pre class="mstretch"><code>void function()
{
    if (int x = rand()) {
        std::cout &lt;&lt; x &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;random 0&quot; &lt;&lt; std::endl;
    } // x is destroyed here
}
</code></pre></section><section><pre class="mstretch"><code>class Logger
{
    private:
        std::ifstream input;
};
// input gets created when a Logger instance gets created
// input gets destroyed when the instance is destroyed
</code></pre></section><section><pre class="mstretch"><code>class Logger
{
    private:
        static std::ifstream input;
};
// input gets created sometime before executing main
// input gets destroyed sometime after main has finished
</code></pre></section><section><pre class="mstretch"><code>int main() {
}
std::ofstream input(&quot;input.txt&quot;);
// input gets created sometime before executing main
// input gets destroyed sometime after main has finished
</code></pre></section><section><pre class="mstretch"><code>void function() {
    static std::ofstream input(&quot;input.txt&quot;);
    // input gets created first time executing the function
}
// input gets destroyed sometime after main has finished
</code></pre></section></section><section><h2>non-automatic variables</h2><pre class="mstretch"><code>// ...
std::ifstream* input = new std::ifstream(&quot;input.txt&quot;);
// ...
delete input; // &lt;-- input gets destroyed here
</code></pre></section><section><h2>Automatic variables are cool</h2><ul><li>deterministic* lifetime</li><li>always* get destroyed</li><li>* - non-static automatic variables</li></ul></section><section><h2>RAII</h2><h2>Resource Acquisition is Initialization</h2><p><ul><li class="fragment fade-in">Obtain the resource in the constructor of an automatic
variable
</li><li class="fragment fade-in">Free the resource in the destructor of an automatic
variable
</li></ul></p></section><section><div data-file="03_resources/lifetime.cxx" data-sections="lifetime" class="snippet"><p>// loading ...</p>
</div><pre class="fragment fade-in"><code>Lifetime:       0x7fffc7c7552f: lives
Lifetime:       0x7fffc7c7552f: dies
</code></pre></section><section><div data-file="03_resources/lifetime.cxx" data-sections="never-member" class="snippet"><p>// loading ...</p>
</div><pre class="fragment fade-in"><code>Lifetime:       0x7fffc7c7552e: lives
NeverMember:    0x7fffc7c7552e: is about to live
Lifetime:       0x7fffc7c7552e: dies
exception:not this time
</code></pre></section><section><div data-file="03_resources/lifetime.cxx" data-sections="never-base" class="snippet"><p>// loading ...</p>
</div><pre class="fragment fade-in"><code>Lifetime:       0x7fffc7c7552d: lives
NeverMember:    0x7fffc7c7552d: is about to live
Lifetime:       0x7fffc7c7552d: dies
exception:not this time
</code></pre></section><section><h2>Lifetime of a local reference</h2></section><section><div data-file="03_resources/lifetime.cxx" data-sections="reference" class="snippet"><p>// loading ...</p>
</div><pre class="fragment fade-in"><code>Lifetime:       0x7fffcbf05d67: lives
Reference to 0x7fffcbf05d67
Lifetime:       0x7fffcbf05d67: dies
</code></pre></section><section><h2>Leaking</h2></section><section><div data-file="03_resources/lifetime.cxx" data-sections="leak" class="snippet"><p>// loading ...</p>
</div><pre class="fragment fade-in"><code>Lifetime:       0x119d010:      lives
Leaking:        0x7fff49285b00: lives
exception: it all goes wrong
</code></pre></section><section>Resource management is difficult not only in presence of exceptions</section><section><pre class="mstretch"><code>bool HasEmbededNull(const char* file)
{
    std::ifstream input(file, std::ios::binary);
    while (input) {
        if (input.get() == '\0') {
            return true;
        }
    }
    return false;
}
</code></pre></section><section><pre class="mstretch"><code>bool HasEmbededNull(const char* file)
{
    auto input = std::fopen(file, &quot;rb&quot;);
    while (input &amp;&amp; !feof(input)) {
        if (fgetc(input) == '\0') {
            return true;
        }
    }
    fclose(input);
    return false;
}
</code></pre></section><section><pre class="mstretch"><code>bool HasEmbededNull(const char* file)
{
    auto input = std::fopen(file, &quot;rb&quot;);
    while (input &amp;&amp; !feof(input)) {
        if (fgetc(input) == '\0') {
            fclose(input); // !!!!!!!!!!!
            return true;
        }
    }
    fclose(input);
    return false;
}
</code></pre></section><section><h2>So the moral is?</h2><p class="fragment fade-in">ALWAYS manage resources following RAII!</p><p class="fragment fade-in">NEVER STORE a resource by a plain pointer!
</p><aside class="notes">By STORE we mean own - if you are just having a reference to use -
then it is OK to be stored by a plain pointer. EXAMPLE!

</aside></section></div></div><script src="/advanced-cpp/bower_components/reveal.js/lib/js/head.min.js"></script><script src="/advanced-cpp/bower_components/reveal.js/js/reveal.min.js"></script><script src="/advanced-cpp/bower_components/reveal.js/plugin/highlight/highlight.js"></script><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/slides.js"></script></body></html>