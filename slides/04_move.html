<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content="A course about C++"><meta name="author" content="SofiaCPP"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="stylesheet" href="/advanced-cpp/bower_components/reveal.js/css/reveal.min.css"/><link rel="stylesheet" href="/advanced-cpp/css/advanced_cxx.css"><link rel="stylesheet" href="/advanced-cpp/css/tomorrow.css"><title>Move Semantics</title></head><body><div class="reveal"><div class="slides"><section><h1>Move Semantics</h1></section><section><h2>Contents</h2><ul><li><code>auto</code></li><li>Return Value Optimization</li><li>Move Semantics</li><li>Sink functions</li><li>Perfect forwarding</li></ul></section><section><h2><code>auto</code></h2><p>Used to denote that a variable has automatic storage.</p><p>In C++ all variables have automatic storage by default.</p></section><section><h2><code>auto</code></h2><p></p><p>In C++11 it gets a new meaning - tells the compiler to deduce
the type of the variable. This is called <a href="http://en.wikipedia.org/wiki/Type_inference" target="_blank" rel="external">type
inference</a></p>
<p></p></section><section><pre class="mstretch"><code>int x = 42;
std::string s = &quot;the answer is&quot;;

auto y = 2 * x; // 2 is int, int * int = int, so y is int
auto t = s + &quot;!&quot;; // std::string + &quot;!&quot; is string, so t is string

</code></pre></section><section><h2 id="Benefits_of_auto">Benefits of <code>auto</code></h2>
<ul><li class="fragment fade-in">saves time determing what is the correct type</li><li class="fragment fade-in">allows to refactor the code by renaming a type</li><li class="fragment fade-in">allows to change the type as long as it
behaves in the same way</li></ul></section><section><pre class="mstretch"><code>BOOL result = ::CreateProcess(...);
if (!result)
{
    DWORD error = ::GetLastError();
    std::cout &lt;&lt; &quot;Could not create process &quot; &lt;&lt; error
        &lt;&lt; std::endl;
}</code></pre></section><section><pre class="mstretch"><code>// don't care what type it is as long as it behaves as a bool
auto result = ::CreateProcess(...);
if (!result)
{
    // don't care what type it is as long as it can be logged
    auto error = ::GetLastError();
    std::cout &lt;&lt; &quot;Could not create process &quot; &lt;&lt; error
        &lt;&lt; std::endl;
}
</code></pre><p class="fragment fade-in">Bonus: I don't get shouted at</p></section><section><pre class="mstretch"><code>std::vector&lt;int&gt; v;
// ...
auto begin = v.cbegin();
std::vector&lt;int&gt;::const_interator begin2 = v.cbegin();
</code></pre></section><section><h2 id="auto_gotchas"><code>auto</code> gotchas</h2>
<ul>
<li>gets the result by value</li>
</ul>
<pre class="mstretch"><code>struct Course {
    std::vector&lt;int&gt;&amp; get_students() const;
}

// ...

auto students = course.get_students();
course.get_students()[0] = 24;
students[0] = 42;
std::cout &lt;&lt; course.get_students()[0] &lt;&lt; std::endl;
// it is still 24
// students is actually a copy
</code></pre></section><section><pre class="mstretch"><code>auto&amp; students = course.get_students();
course.get_students()[0] = 24;
students[0] = 42;
std::cout &lt;&lt; course.get_students()[0] &lt;&lt; std::endl;
// it is 42
</code></pre><p>The difference is only the <strong>&amp;</strong> after auto</p>
</section><section><p>Taking a const reference with auto</p><pre class="mstretch"><code>const auto&amp; students = course.get_students();
</code></pre></section><section><h2>Return Value Optimization</h2><p class="fragment fade-in">RVO</p></section><section><h2>Values returned from functions are copied in the local variables</h2></section><section><pre class="mstretch"><code>std::vector&lt;int&gt; get_random_ints(int count);
// ...
auto numbers = get_random_ints(1000);
</code></pre></section><section><p>You can get advice to not return such expensive to copy things by</p>value<pre class="mstretch"><code>void get_random_ints(int count, std::vector&lt;int&gt;&amp; numbers);
// ...
std::vector&lt;int&gt; numbers;
get_random_ints(1000, numbers);
</code></pre><ul class="fragment fade-in"><li>more code</li></ul></section><section><h2>Optimizations</h2><p>Compilers are allowed to make any optimization as long as the
program behaves in the same way as if there are no optimizations</p></section><section><h2>RVO</h2><p>C++ allows compilers to implement RVO even breaking this rule</p></section><section><h2>How is RVO implemented by compilers<pre class="mstretch"><code>std::vector&lt;int&gt; get_random_ints(int count);
// ...
auto numbers = get_random_ints(1000);
</code></pre></h2><p>Gets compiled as<pre class="mstretch"><code>void get_random_ints(int count, std::vector&lt;int&gt;&amp; numbers);
// ...
std::vector&lt;int&gt; numbers;
get_random_ints(1000, numbers);
</code></pre></p></section><section><h3>RVO doesn't always work</h3><pre class="mstretch"><code>std::vector&lt;int&gt; get_numbers() {
    std::vector&lt;int&gt; result;
    // ...
    return (rand() % 2)? result : std::vector&lt;int&gt;();
}
</code></pre></section><section><h2>Move</h2><p class="fragment fade-in">Instead of copying values move them directly into their new
variables
</p></section><section><h2 id="Move">Move</h2>
<p>In C++ it is easy to create unnecessary copies of object,
hurting performance.</p>
</section><section><pre class="mstretch"><code>std::string s = &quot;Hello&quot;;
std::string t = &quot;World&quot;;
std::string m = s + t;
</code></pre><p class="fragment fade-in"></p><p><em><code>s</code></em> is concatenated with <em><code>t</code></em> in a temporary string
which is then copied into <em><code>m</code></em></p>
<p><em>assuming that the compiler will not optimize the code</em></p>
<p></p></section><section><h2 id="lvalues_and_rvalues"><em>lvalues</em> and <em>rvalues</em></h2>
<ul>
<li>come from C</li>
<li><em>lvalues</em> are on the left side of <code>operator =</code></li>
<li><em>rvalues</em> are on the right side of <code>operator =</code></li>
</ul>
</section><section><h2 id="lvalues_and_rvalues-1"><em>lvalues</em> and <em>rvalues</em></h2>
<ul>
<li>In C++</li>
<li><em>lvalues</em> are variables - names of the values, storage for the
  value</li>
<li><em>rvalues</em> are values of expressions</li>
</ul>
</section><section><h2 id="Rule_of_thumb">Rule of thumb</h2>
<ul>
<li><code>T&amp;&amp;</code> can be both - lvalue and rvalue</li>
<li>If it has has a <em>name</em> it is an <em>lvalue</em></li>
</ul>
</section><section><pre class="mstretch"><code>Derived(Derived&amp;&amp; other) 
  : Base(other) // wrong: other is an lvalue --&gt; copies the Base part
{
    // ...
}</code></pre></section><section><pre class="mstretch"><code>Derived(Derived&amp;&amp; other) 
  : Base(std::move(other)) // :)
{
    // ...
}
</code></pre></section><section><ul><li class="fragment fade-in">lvalue reference <code>T&</code></li><li class="fragment fade-in">rvalue reference <code>T&&</code></li></ul></section><section><h2 id="const_T&amp;"><code>const T&amp;</code></h2>
<p>Can reference everything - values stored in variables, result
values of expressions.</p>
</section><section><h2 id="const_T&amp;&amp;"><code>const T&amp;&amp;</code></h2>
<p>Can reference only result values of expressions</p>
</section><section><pre class="mstretch"><code>void function(const std::string&amp; lvalue);  // lvalue overload
void function(const std::string&amp;&amp; rvalue); // rvalue overload
</code></pre><given>both declarations, the compiler chooses which overload to call<based>on the type of the string value.</based></given></section><section><pre class="mstretch"><code>std::string s = &quot;Hello World&quot;;
function(s); // lvalue overload

function(&quot;Hello World&quot;); // rvalue overload
// the const char* is converted to a temporary string which can be
// rvalue
</code></pre></section><section><pre class="mstretch"><code>class String {
public:
    String(const char* s)
        : m_Length(std::strlen(s))
        , m_Buffer(new char[m_Length])
    {
        std::memcpy(m_Buffer, s, m_Length);
    }
    
    ~String() {
        delete [] m_Buffer;
    }
    
private:
    size_t m_Length;
    char* m_Buffer;
};</code></pre></section><section><h3>String representation</h3><img width="100%" src="04_move/storage.svg"></section><section><h3>Copy constructor</h3><pre class="mstretch"><code>String(const String&amp; o)
    : m_Length(o.m_Length)
    , m_Buffer(new char[m_Length])
{
    std::memcpy(m_Buffer, o.m_Buffer, m_Length);
}</code></pre><p>Create a copy of the other string</p></section><section><h3>Copy construction</h3><img width="100%" src="04_move/copy.svg"></section><section><h3>Move constructor</h3><pre class="mstretch"><code>class String {
    // ...
    String(String&amp;&amp; o)
        : m_Buffer(o.m_Buffer)
        , m_Length(o.m_Length)
    {
        o.m_Buffer = nullptr;
        o.m_Length = 0;
    }
    
String(const String&amp;&amp; o)</code></pre><p>Moves the value of the other string into this object</p></section><section><h3>Move construction</h3><img width="100%" src="04_move/move.svg"></section><section><pre class="mstretch"><code>String s(&quot;Hello&quot;);
String t(&quot;World&quot;);

String s2 = s; // copy
String t2 = s + t; // move
</code></pre></section><section><h2 id="std::move"><code>std::move</code></h2>
<p>Tells the compiler to create an rvalue reference for an lvalue.
Allows us to move ordinary values stored in variables.</p>
</section><section><pre class="mstretch"><code>template &lt;typename T&gt;
T&amp;&amp; std::move(T&amp; lvalue);</code></pre></section><section><pre class="mstretch"><code>String s(&quot;Hello&quot;);
String t = std::move(s); // move s into t

// !!! Undefined behavior !!!
std::cout &lt;&lt; s &lt;&lt; std::endl;
// We have moved s into t, it's value is unknown
</code></pre></section><section><h2>Assignment operator</h2><pre class="mstretch"><code>class String {
    // ..
    
    String&amp; operator= (const String&amp; rhs) {
        if (this != &amp;rhs) {
            delete [] m_Buffer;
            m_Length = rhs.m_Length;
            m_Buffer = new char[rhs.m_Length];
            std::memcpy(m_Buffer, rhs.m_Buffer, m_Length);
        }
        return *this;
    }</code></pre></section><section><h2>Assignment operator</h2><p>before</p><img width="100%" src="04_move/assign.svg"></section><section><h2>Assignment operator</h2><p>after</p><img width="100%" src="04_move/copy_assign.svg"></section><section><h2>Move assignment</h2><pre class="mstretch"><code>class String {
    // ..
    // move assignment
    String&amp; operator= (String&amp;&amp; rhs) {
        if (this != &amp;rhs) {
            delete [] m_Buffer;
            m_Length = rhs.m_Length;
            m_Buffer = rhs.m_Buffer;
            rhs.m_Length = 0;
            rhs.m_Buffer = nullptr;
            rhs.m_Length = 0;
        }
        return *this;
    }
};
</code></pre></section><section><h2>Move Assignment</h2><p>before</p><img width="100%" src="04_move/assign.svg"></section><section><h2>Move Assignment</h2><p>after</p><img width="100%" src="04_move/move_assign_1.svg"></section><section><h2>Copy or Move?</h2><pre class="mstretch"><code>String s = &quot;Hello&quot;;
String t = &quot;World&quot;;

String m = s + t; // 1
m = t + s; // 2

m = t; // 3
m = std::move(s); // 4</code></pre><ol><li class="fragment fade-in">move</li><li class="fragment fade-in">move</li><li class="fragment fade-in">copy</li><li class="fragment fade-in">move</li></ol></section><section><h2>Move assignment - alternative implementation</h2><pre class="mstretch"><code>class String {
    // ..
    // move assignment
    String&amp; operator= (String&amp;&amp; rhs) {
        std::swap(m_Buffer, rhs.m_Buffer);
        std::swap(m_Length, rhs.m_Length);
        return *this;
    }
};
</code></pre></section><section><h2>Move Assignment - alternative implementation</h2><p>before</p><img width="100%" src="04_move/assign.svg"></section><section><h2>Move Assignment - alternative implementation</h2><p>after</p><img width="100%" src="04_move/move_assign_2_1.svg"></section><section><h2>Move Assignment - alternative implementation</h2><p>in the end</p><img width="100%" src="04_move/move_assign_2.svg"></section><section><strong>Although the value of an object may be moved, the object is still
going to be destoyed (its constructor has been run)
</strong></section><section><h2>Always leave moved object in a consistent state</h2><p>So that their destructor will run correctly.</p></section><section><section><h2>Perfect forwarding</h2></section><section><pre class="mstretch"><code>template &lt;typename T, typename Arg1&gt;
T factory(/*const*/ Arg1 /*&amp;*/ arg1)
{
    return T(arg1);
}</code></pre><ul>
<li><code>Arg1 arg1</code></li>
<li><code>Arg1&amp; arg1</code></li>
<li><code>const Arg1&amp; arg1</code></li>
</ul>
</section><section><h3 id="Arg1_arg1"><code>Arg1 arg1</code></h3>
<ul>
<li>will be <em>wrong</em> if T stores a reference/pointer to the value</li>
<li>extra copying</li>
</ul>
</section><section><h3 id="Arg1&amp;_arg1"><code>Arg1&amp; arg1</code></h3>
<ul>
<li>will be <em>OK</em> if T stores a reference/pointer to the value</li>
<li><em>no</em> extra copying</li>
<li>will <em>NOT</em> work for const references and temporaries</li>
</ul>
</section><section><h3 id="const_Arg1&amp;_arg1"><code>const Arg1&amp; arg1</code></h3>
<ul>
<li>will be <em>OK</em> if T stores a <strong><code>const</code></strong> reference/pointer to the
value</li>
<li><em>no</em> extra copying</li>
<li>will work for const references and temporaries</li>
</ul>
</section><section><h3>And now what?</h3></section><section><h3>Overloading</h3><pre class="mstretch"><code>template &lt;typename T, typename Arg1&gt;
T factory(Arg1&amp; arg1);

template &lt;typename T, typename Arg1&gt;
T factory(const Arg1&amp; arg1);

// How about
template &lt;typename T, typename Arg1, typename Arg2&gt;
T factory(const Arg1&amp; arg1, const Arg2&amp; arg2);</code></pre></section><section><h3 id="&amp;&amp;"><code>&amp;&amp;</code></h3>
<ul>
<li><code>T&amp; + &amp;</code>   --&gt; <code>T&amp;</code></li>
<li><code>T&amp; + &amp;&amp;</code>  --&gt; <code>T&amp;</code></li>
<li><code>T&amp;&amp; + &amp;</code>  --&gt; <code>T&amp;</code></li>
<li><code>T&amp;&amp; + &amp;&amp;</code> --&gt; <code>T&amp;&amp;</code></li>
</ul>
</section><section><h3>Perfect forwading</h3><pre class="mstretch"><code>template &lt;typename T, typename Arg1&gt;
T factory(Arg1&amp;&amp; arg1)
{
    return T(std::forward&lt;Arg1&gt;(arg1));
}
</code></pre></section><section><h3 id="std::forward"><code>std::forward</code></h3>
<pre class="mstretch"><code>template&lt;class S&gt;
S&amp;&amp; forward(typename remove_reference&lt;S&gt;::type&amp; a) noexcept
{
    return static_cast&lt;S&amp;&amp;&gt;(a);
}</code></pre></section></section><section><p><a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank" rel="external">http://thbecker.net/articles/rvalue_references/section_01.html</a></p>
</section></div></div><script src="/advanced-cpp/bower_components/reveal.js/lib/js/head.min.js"></script><script src="/advanced-cpp/bower_components/reveal.js/js/reveal.min.js"></script><script src="/advanced-cpp/bower_components/reveal.js/plugin/highlight/highlight.js"></script><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/slides.js"></script></body></html>